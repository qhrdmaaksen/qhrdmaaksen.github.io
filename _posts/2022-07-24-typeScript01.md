---
layout: post
title: "typescript master with webpack & react !"
---

### 타입스크립트를 배워보자

```js

- typescript 는 최종적으로 javascript 로 변환됨
- typescript 는 tsc 라는 컴파일러를 제공함
- tsc 는 옵션에 따라서 특정 javascript 버전을 최신 javascript 로 변환해줌
- tsc 는 타입 검사를 해주는 역할도 해줌
- 타입 검사만 하고싶다면 tsc --noEmit 하면됨
- 타입 에러가 나더라도 javascript 에서는 변환을 해줌 (하지만 타입 에러가 없는 코드를 만들어야함)
- ts 파일을 실행하는게 아니라 결과물인 js 를 실행해야 함
- 에디터가 필수가 되며 메모장으로 코딩 불가능한 지경임
-작성과 동시에 분석을 함으로써 실행할 필요 없이 문제를 찾아준다
-any type 을 명시 해주면 ts 에서 기본적으로 확인하는걸 모두 무시함

타입 추론
- ts 는 할당된 변수를 토대로타입을 추론 할 수 있지만 예를들어
변수가 문자열이 아니라 문자열 배열 타입이라고 사용할땐 애너테이션으로 타입을 직접 할당해줘야함


-void 와 never 차이점
  never과 void와 비교하면 void는 엄밀히 값입니다 void를 반환한 함수죠 undefined 상태로 반환됩니다
  이 함수가 무엇을 반환해도 상관하지 않고 사용하지 않죠 void는 신경 쓸 필요 없는 걸 반환하죠
  반면에 never은 이 함수가 절대 반환할 기회를 가지면 안 된다고 하죠 이게 차이입니다
// never 는 절대 리턴되지 않는다는 의미, 무한루프에 사용 가능
const makeError = (msg: string): never =>{
	throw new Error(msg);
}
// never 는 절대 리턴되지 않는다는 의미, 무한루프에 사용 가능
const gameLoop = (): never => {
	while(true){
		console.log('안녕 나는 무한 루프야');
	}
}


-객체 리터럴 형태의 반환 타입 애너테이션을 가지는 함수를 만들 수 있고
객체 타입을 사용하는 변수를 가질 수도 있고 물론 함수에 대한 파라미터 타입 애너테이션을 작성해
객체가 되게 할 수도 있습니다

// 객체 값 타입 설정 및 함수 타입 설정
const printName = (person: { first: string, last: string }): void => {
	console.log(`${person.first} ${person.last}`);
}
-불필요한 프로퍼티는 전달하지 못하게 만들고요
직접 객체 리터럴을 전달하는 경우에는 오류를 띄우지만
사전에 별도의 변수로 정의하는 과정을 거치면 지정된 프로퍼티 외에는 그냥 무시하게 됩니다
printName({first: 'vitamin', last: '777', age: 333});
const singer = {first: 'vitamin', last: '777', age: 333};
printName(singer)


--------------------타입 별칭---------------------------
// 타입 별칭은 타입을 새로 정의하는 것이 아니라 기존 타입에 새로운 이름을 붙이는 것입니다.
// 타입 별칭은 기존 타입에 새로운 이름을 붙이는 것이기 때문에 기존 타입과 같은 속성을 가집니다.

----------------------선택적 프로퍼티------------------------
type PointerPOPO = {
	x: number
	y: number
	z?: number
}
z 뒤에 물음표를 넣어주면 됩니다 타입 애너테이션 전에 필수는 아니라고 TypeScript에 전달하는 거죠
여기서 z를 없애도 아무 문제 없고요 하지만 물음표를 지우면 z가 꼭 필요하다면서 오류를 띄웁니다
이렇게 물음표를 넣어서 선택적 요소로 만들 수 있습니다
const printPointerPOPO:PointerPOPO = {x: 1, y: 2, z : 3}

----------------------readonly 제어자------------------------
/*객체의 프로퍼티를 readonly로 표시하면 TypeScript에서는 우리가 프로퍼티에 쓰기를 해서 변경할 때 경고를 해줘요
* 주의하실 점은, 참고하는 객체가 있는 경우 여기서는 id라는 숫자 자리에 객체나 배열을 놓으면
그 객체와 배열을 추가, 갱신 변경할 수 있습니다 참조하는 거니깐요
하지만 원시 타입인 숫자 프로퍼티를 완전히 재할당하는 건 불가능해요
프로퍼티에 손을 댈 수는 없고 접근만 할 수 있는 거죠*/
type User = {
	readonly id: number
	userName: string
}
const user:User = {
	id: 325234,
	userName: 'catGuy'
}
console.log(user.id)
// 변경 불가
user.id = 245234;

 ----------------------교차 타입------------------------
type Circle = {
	radius: number
}
type Colorful = {
	color: string
}
type CircleColorful = Circle & Colorful // 교차 타입
const happyFace: CircleColorful = {
	radius: 4,
	color: 'yellow'
}
console.log(happyFace);
type Cat = {
	numLives: number
}
type Dog = {
	breed: string
}
교차 타입을 사용하면 두 타입의 모든 프로퍼티를 가지는 타입을 만들 수 있습니다 
이렇게 두 타입을 &로 연결하면 두 타입의 모든 프로퍼티를 가지는 타입을 만들 수 있습니다
만약 추가 프로퍼티를 넣고 싶다면 & 뒤에 추가 객체 타입을 넣어주면 됩니다
type CatDog = Cat & Dog & {age: number}
const woomi: CatDog = {
	numLives: 9,
	breed: 'maltiz',
	age: 15
}
console.log(woomi)

--------------------------타입 별칭 연습 문제-------------
// 다음 두 변수가 올바르게 입력되도록 Movie 유형 별칭을 작성합니다.
// "originalTitle"은 선택 사항이고 "title"은 읽기 전용인지 확인합니다.
type Movie = {
  readonly title: string;
  originalTitle?: string
  director: string
  releaseYear: number
  boxOffice: {budget: number, grossUS: number, grossWorldwide: number}
}
const dune: Movie = {
  title: "Dune",
  originalTitle: "Dune Part One",
  director: "Denis Villeneuve",
  releaseYear: 2021,
  boxOffice: {
    budget: 165000000,
    grossUS: 108327830,
    grossWorldwide: 400671789,
  },
};
const cats: Movie = {
  title: "Cats",
  director: "Tom Hooper",
  releaseYear: 2019,
  boxOffice: {
    budget: 95000000,
    grossUS: 27166770,
    grossWorldwide: 73833348,
  },
};
// 단일 Movie 객체를 허용하는 getProfit이라는 함수를 작성하십시오.
// 영화의 전 세계 총수입에서 예산을 뺀 값을 반환해야 합니다.
첫 번째 방법 직접 객체 속성에 접근 작성
const getProfit = (budgetValue: Movie): number => {
  return budgetValue.boxOffice.grossWorldwide - budgetValue.boxOffice.budget
}

두 번째 방법 구조 분해 할당 작성
const getProfit = (movie: Movie): number => {
  const {budget, grossWorldwide} = movie.boxOffice
  return grossWorldwide - budget
}

세 번째 방법 중첩 구조 분해 할당과 매개 변수 기본값 작성
const getProfit = ({boxOffice: {budget, grossWorldwide}}:Movie): number => {
  return grossWorldwide - budget
}
console.log(getProfit(dune))
console.log(getProfit(cats))






```