---
layout: post
title: "hycu Recap"
---

## 코드는 재산이다, 나중에 도움된다, 정리잘하자

```js

2023 정보처리기술

-1- 데이터베이스의 정의와 기본 개념
- 데이터베이스: 조직에 필요한 데이터를 효율적으로 관리하기 위해 통합하여 저장한 데이터의 집합
-- 데이터베이스 시스템은 데이터의 검색과 변경 작업을 주로 수행

- 정보시스템 
-- 조직 운영에 필요한 정보를 수집, 저장해두었다가 필요할 때 유용한 정보를 만들어 내는 시스템

- 데이터베이스의 특징
-- 실시간 접근성: 데이터베이스에 저장된 데이터는 사용자의 요구에 따라 언제든지 접근 가능
-- 계속적인 변화: 데이터베이스는 실시간으로 데이터를 추가, 삭제, 수정할 수 있음
-- 동시 공유: 여러 사용자가 동시에 데이터베이스에 접근할 수 있음
-- 내용에 의한 참조: 데이터베이스에 저장된 데이터는 데이터의 내용을 통해 참조 가능

- 데이터베이스의 구조적 형태
-- 개념적 구조를 논리적 구조로 표현하는 논리적 데이터 모델
-- 하나의 개체에 대한 데이터를 하나의 릴레이션에 저장

- 데이터베이스의 발전 배경
-- 파일을 중심으로 한 종래의 자료 처리 시스템에서는 각 응용프로그램이 개별적으로 자기 자신의 데이터파일을 관리 유지

- 데이터의 종속성과 중복성
-- 데이터의 종속성: 데이터의 논리적 구조를 표현하는 데 있어서 데이터 간의 관계를 표현하는 것
-- 데이터의 중복성: 데이터베이스에 저장된 데이터가 중복되어 저장되는 것

- 데이터베이스의 설계 순서
-- 요구사항 분석: 데이터베이스를 구축하기 위한 요구사항을 분석
-- 개념적 설계: 데이터베이스의 개념적 구조를 설계
-- 논리적 설계: 데이터베이스의 논리적 구조를 설계
-- 물리적 설계: 데이터베이스의 물리적 구조를 설계

- 스키마의 정의
-- 외부스키마 : 사용자의 입장에서 데이터베이스의 구조를 표현
-- 개념스키마 : 데이터베이스의 전체적인 구조를 표현
-- 내부스키마 : 데이터베이스의 물리적 저장 구조를 표현

- 스키마에서 데이터의 독립성
-- 논리적 데이터 독립성: 데이터베이스의 논리적 구조를 변경해도 응용 프로그램은 변경하지 않아도 됨
-- 물리적 데이터 독립성: 데이터베이스의 물리적 저장 구조를 변경해도 응용 프로그램은 변경하지 않아도 됨

- 데이터 모델링
-- 데이터 모델링: 데이터베이스를 구축하기 위한 요구사항을 분석하여 데이터베이스의 논리적 구조를 설계하는 과정
-- 개념적 데이터 모델링: 데이터베이스의 전체적인 논리적 구조를 설계
-- 논리적 데이터 모델링: 데이터베이스의 논리적 구조를 설계
-- 물리적 데이터 모델링: 데이터베이스의 물리적 저장 구조를 설계

- 관계형 데이터베이스
-- 관계형 데이터베이스: 데이터를 테이블 형태로 저장하고, 테이블 간의 관계를 통해 데이터를 연결하는 데이터베이스
-- 속성: 테이블의 열
-- 튜플: 테이블의 행

- 릴레이션 구조와 관련된 용어
-- 릴레이션: 테이블
-- 튜플: 테이블의 행
-- 속성: 테이블의 열
-- 도메인: 속성의 값으로 사용할 수 있는 값의 집합
-- 도메인의 원자값: 도메인의 원소
-- 도메인의 차수: 도메인의 원자값의 개수
-- 릴레이션 스키마: 릴레이션의 구조를 정의한 것
-- 릴레이션 인스턴스: 릴레이션에 저장된 데이터

- 관계형 데이터베이스의 특징
-- 데이터 중복 최소화: 데이터베이스에 저장된 데이터는 중복되어 저장되지 않음
-- 데이터 무결성 유지: 데이터베이스에 저장된 데이터는 무결성을 유지해야 함
-- 데이터 일관성 유지: 데이터베이스에 저장된 데이터는 일관성을 유지해야 함
-- 데이터 독립성 유지: 데이터베이스에 저장된 데이터는 독립성을 유지해야 함

- 관계
-- 관계: 릴레이션 간의 연관성을 표현하는 것

- 키의 개념
-- 키: 릴레이션에서 튜플을 유일하게 식별할 수 있는 속성 또는 속성의 집합
-- 키의 필요성
--- 키를 사용하면 릴레이션에서 튜플을 유일하게 식별할 수 있음

- 후보키
-- 후보키: 릴레이션에서 튜플을 유일하게 식별할 수 있는 최소한의 속성 또는 속성의 집합
-- 후보키의 성질
--- 유일성: 튜플을 유일하게 식별할 수 있어야 함
--- 최소성: 유일성을 만족하는 속성 또는 속성의 집합은 더 이상 줄일 수 없어야 함

- 기본키
-- 기본키: 후보키 중에서 선택한 키
-- 기본키의 성질
--- NULL 값을 가질 수 없음
--- 중복된 값을 가질 수 없음
--- 변경될 수 없음

- 대체키
-- 대체키: 후보키 중에서 기본키로 선택되지 않은 키
-- 대체키의 성질
--- NULL 값을 가질 수 있음
--- 중복된 값을 가질 수 있음
--- 변경될 수 있음

- 외래키
-- 외래키: 다른 릴레이션의 기본키를 참조하는 속성
-- 외래키의 성질
--- NULL 값을 가질 수 있음
--- 중복된 값을 가질 수 있음
--- 변경될 수 있음

- 키 종류 정리
-- 후보키: 릴레이션에서 튜플을 유일하게 식별할 수 있는 최소한의 속성 또는 속성의 집합
-- 기본키: 후보키 중에서 선택한 키
-- 대체키: 후보키 중에서 기본키로 선택되지 않은 키
-- 외래키: 다른 릴레이션의 기본키를 참조하는 속성

- 데이터베이스 관리 시스템
-- 기존의 파일 시스템이 갖는 데이터의 종속성과 중복성의 문제를 해결하기 위해 제안된 시스템으로 모든 응용 프로그램들이 데이터베이스를 공용할 수 있도록 관리해주는 소프트웨어
-- 데이터를 편리하게 저장하고 효율적으로 관리하고 검색할 수 있는 환경을 제공해주는 소프트웨어
-- 데이터베이스의 생성과 관리를 담당하는 소프트웨어 패키지

- 데이터베이스 관리 시스템의 구성요소
-- 데이터베이스: 데이터베이스 관리 시스템이 관리하는 데이터의 집합
-- 데이터베이스 관리 시스템: 데이터베이스를 관리하는 소프트웨어
-- 데이터베이스 언어: 데이터베이스 관리 시스템과 사용자 간의 인터페이스를 제공하는 언어
-- 데이터베이스 응용 프로그램: 데이터베이스 관리 시스템을 사용하여 데이터베이스를 관리하는 응용 프로그램

- DBMS 의 장단점
-- 장점
--- 데이터의 무결성을 보장
--- 데이터의 중복을 최소화
--- 데이터의 독립성을 보장
--- 데이터의 보안성을 보장
--- 데이터를 동시 공유할 수 있음
--- 장애 발생시 회복 가능
--- 응용 프로그램 개발 비용 감소
-- 단점
--- 데이터베이스 관리 시스템의 구축 비용이 많이 듬
--- 백업과 회복 방법이 복잡
--- 중앙 집중 관리로 인한 취약점이 존재함

- dbms 의 발전
-- 계층형 데이터베이스
--- 데이터베이스를 계층적으로 구성하여 데이터를 관리하는 방식
-- 관계형 데이터베이스
--- 데이터베이스를 테이블의 집합으로 구성하여 데이터를 관리하는 방식
-- 객체지향 데이터베이스
--- 데이터베이스를 객체의 집합으로 구성하여 데이터를 관리하는 방식
-- 객체관계형 데이터베이스
--- 데이터베이스를 객체와 관계의 집합으로 구성하여 데이터를 관리하는 방식
-- NoSQL 데이터베이스
--- 데이터베이스를 키-값 쌍의 집합으로 구성하여 데이터를 관리하는 방식

- DBMS 의 필수기능
-- 정의기능: 모든 응용 프로그램들이 요구하는 데이터 구조를 지원하기 위해 db 에 저장될 데이터의 형과 구조에대한 정의 이용방식, 제약 조건등을 명시하는 기능
-- 조작기능: 데이터베이스에 데이터를 저장하고 검색, 갱신, 삽입, 삭제기능
-- 제어기능: 데이터베이스의 무결성을 유지하고 데이터의 독립성을 보장하는 기능
-- 추출기능: 데이터베이스에서 데이터를 추출하는 기능


- 관계대수
-- 원하는 결과를 얻기 위해 릴레이션의 처리과정을 순서대로 기술하는 언어 (절차 언어)
-- 관계대수의 일반 집합 연산자
--- 합집합 연산자: 두 릴레이션의 합집합을 구하는 연산자
--- 교집합 연산자: 두 릴레이션의 교집합을 구하는 연산자
--- 차집합 연산자: 두 릴레이션의 차집합을 구하는 연산자
--- 카티션 프로덕트 연산자: 두 릴레이션의 각 튜플을 모두 연결해 만들어진 새로운 튜플 반환
(모든 경우의 수를 다 표현함)

-- 순수 관계 연산자
--- 셀렉트 연산자: 릴레이션에서 특정 조건을 만족하는 튜플만을 선택하여 구성하는 연산자
--- 프로젝션 연산자: 릴레이션에서 주어진 속성들의 값으로만 구성된 튜플들을 반환
--- 조인 연산자: 두 릴레이션에서 주어진 속성들의 값이 같은 튜플들을 연결해 만들어진 새로운 튜플들을 반환
--- 디비전 연산자: 한쪽에 조건을 만족하는 조건을 뽑아내는 연산자


SQL 의 정의와 종류 
-- 정의: db 관리 시스템에서 데이터를 관리하기위해 사용되는 표준 프로그래밍 언어
-- 종류: DDL, DML, DCL
-- 특징: 데이터베이스를 관리하기 위한 표준 언어로서, 데이터베이스를 생성, 삭제, 수정, 조회하는데 사용되는 언어

- DDL (Data Definition Language)
-- 데이터베이스의 구조를 정의하는 언어
-- 데이터베이스를 생성, 삭제, 수정하는데 사용되는 언어

- DML (Data Manipulation Language)
-- 데이터베이스의 데이터를 조작하는 언어
-- 데이터베이스에 데이터를 삽입, 삭제, 갱신하는데 사용되는 언어

- DCL (Data Control Language)
-- 데이터베이스의 접근 권한을 관리하는 언어
-- 데이터베이스에 접근할 수 있는 사용자를 관리하는데 사용되는 언어


- sql 과 프로그래밍 언어의 차이점
-- sql 은 데이터베이스를 관리하기 위해 사용되는 표준 언어이며, 프로그래밍 언어는 프로그램을 개발하기 위해 사용되는 언어


- SELECT 문
-- SELECT 문의 활용
--- SELECT * FROM 테이블명; (모든 속성을 조회)

- 조건 검색 
-- WHERE 절의 활용
--- SELECT * FROM 테이블명 WHERE 조건식; (조건식에 해당하는 튜플만 조회)

- 복합 조건
-- AND, OR, NOT 연산자의 활용
--- SELECT * FROM 테이블명 WHERE 조건식1 AND 조건식2; (조건식1과 조건식2를 모두 만족하는 튜플만 조회)

- 정렬
-- ORDER BY 절의 활용
--- SELECT * FROM 테이블명 ORDER BY 속성명; (튜플을 속성명의 오름차순으로 정렬하여 조회)

- 집계와 그룹화
-- 집계함수의 활용
--- SELECT 집계함수(속성명) FROM 테이블명; (특정 속성의 집계값을 조회)

- 조인
-- 조인의 활용
--- SELECT * FROM 테이블명1, 테이블명2 WHERE 조건식; (조건식을 만족하는 테이블명1과 테이블명2의 튜플을 연결하여 조회)

- 집합 연산
-- UNION, INTERSECT, MINUS 연산자의 활용
--- SELECT * FROM 테이블명1 UNION SELECT * FROM 테이블명2; (테이블명1과 테이블명2의 합집합을 조회)
--- SELECT * FROM 테이블명1 INTERSECT SELECT * FROM 테이블명2; (테이블명1과 테이블명2의 교집합을 조회)
--- SELECT * FROM 테이블명1 MINUS SELECT * FROM 테이블명2; (테이블명1과 테이블명2의 차집합을 조회)


- 데이터 정의어
-- CREATE: 데이터베이스 객체를 생성
--- CREATE TABLE 테이블명 (속성명1 속성타입1, 속성명2 속성타입2, ...);
-- ALTER: 데이터베이스 객체를 수정
--- ALTER TABLE 테이블명 ADD 속성명 속성타입;
-- DROP: 데이터베이스 객체를 삭제
--- DROP TABLE 테이블명;

- 데이터 조작어
-- INSERT: 테이블에 튜플을 삽입
--- INSERT INTO 테이블명 VALUES (값1, 값2, ...);
-- UPDATE: 테이블의 튜플을 갱신
--- UPDATE 테이블명 SET 속성명 = 값 WHERE 조건식;
-- DELETE: 테이블의 튜플을 삭제
--- DELETE FROM 테이블명 WHERE 조건식;

- 데이터 제어어
-- GRANT: 사용자에게 권한을 부여
--- GRANT 권한 ON 객체 TO 사용자;
-- REVOKE: 사용자에게 부여된 권한을 취소
--- REVOKE 권한 ON 객체 FROM 사용자;


- 데이터 이상: 하나의 릴레이션 내에 데이터의 중복과 종속으로 인해 발생되는 문제점
-- 삽입 이상: 새로운 튜플을 삽입할 때 원하지 않는 값이 삽입될 수 있는 현상
-- 삭제 이상: 튜플을 삭제할 때 원하지 않는 튜플까지 삭제될 수 있는 현상
-- 갱신 이상: 튜플을 갱신할 때 원하지 않는 튜플까지 갱신될 수 있는 현상


- 데이터의 함수적 종속성: A 의 값을 알면 B 의 값을 알수있거나 A 값에 따라 B 의 값이 달라진다면 B 는 A에 종속되어있음
-- 함수적 종속성: 릴레이션의 속성들 사이에 존재하는 종속성
-- 완전 함수적 종속성: 릴레이션의 모든 속성들이 결정자가 되는 종속성
-- 부분 함수적 종속성: 릴레이션의 일부 속성들이 결정자가 되는 종속성
-- 이행적 함수적 종속성: A 를 알면 B 를 알 수 있고, B 를 알면 C 를 알 수 있을 때 A 는 C 에 함수적 종속성이 있다고 함


-데이터 정규화 고려 사항
-- 실전에서의 정규화 전략
--- 정규화 전략의 결정은 데이터의 특성과 응용 시스템의 특성을 고려하여 결정

-- 데이터 정규화의 유형
--- 1차 반복되는 속성 제거 
--- 2차 부분함수 종속성 제거
--- 3차 이행함수 종속성 제거 
--- BCNF 결정자 함수 종속성 제거
--- 4차 다중값 종속성 제거
--- 5차 결합 종속성 제거


데이터 정규화의 절차
-- 1차 정규화: 릴레이션에 존재하는 모든 속성들이 원자값만을 가지도록 분해
-- 2차 정규화: 릴레이션에 존재하는 모든 속성들이 완전 함수적 종속을 만족하도록 분해
-- 3차 정규화: 릴레이션에 존재하는 모든 속성들이 이행적 함수적 종속을 만족하도록 분해
-- BCNF 정규화: 릴레이션에 존재하는 모든 속성들이 BCNF를 만족하도록 분해
-- 4차 정규화: 릴레이션에 존재하는 모든 속성들이 다중값 종속을 만족하도록 분해
-- 5차 정규화: 릴레이션에 존재하는 모든 속성들이 결합 종속을 만족하도록 분해


- 역정규화의 정의
-- 역정규화: 데이터 정규화를 통해 분해된 릴레이션을 다시 결합하여 정규화 전의 릴레이션으로 복원하는 과정
-- 역정규화의 목적: 데이터베이스의 성능을 향상시키기 위해 데이터 정규화를 통해 분해된 릴레이션을 다시 결합하는 과정



1.뷰의 개념과 특징
- 하나 이상의 테이블을 합해 만든 가상의 테이블
- 데이터 보정 작업, 처리 과정 시험 등 임시적인 작업을 위한 용도로 활용
- 저장장치 내에 물리적으로 존재하지 않지만 사용자에게 있는것처럼 간주됨
- 사용자에게 접근이 허용된 자료만을 제한적으로 보여주기 위해 하나 이상의 기본 테이블로부터 유도된 가상 테이블

사용상의 이점
- 재사용성: 뷰를 정의하면 뷰를 사용하는 어떤 응용 프로그램에서도 뷰를 사용할 수 있음
- 보안성: 뷰를 정의하면 뷰를 사용하는 응용 프로그램에서는 뷰에 정의된 속성만을 사용할 수 있음
- 논리적 데이터 독립성: 뷰를 정의하면 뷰를 사용하는 응용 프로그램은 뷰에 정의된 속성만을 사용하므로 뷰를 정의하는 물리적 구조에 영향을 받지 않음

뷰의 사용 방법
- 뷰의 생성 : CREATE VIEW 뷰이름 AS SELECT문
- 뷰의 삭제 : DROP VIEW 뷰이름
- 뷰의 조회 : SELECT * FROM 뷰이름
- JOIN 을 활용한 뷰 생성 : CREATE VIEW 뷰이름 AS SELECT문 FROM 테이블1이름 A, 테이블2이름 B WHERE a.컬럼1 = b.컬럼2
ex code 
Book 테이블에서 "축구" 라는 문구가 포함된 자료만 보여주는 뷰 만들기
CREATE VIEW BookView AS SELECT * FROM Book WHERE BookName LIKE '%축구%';
ex code
주소에 "대한민국"을 포함하는 고객들로 구성된 뷰를 만들고 조회하시오. 뷰의 이름은 vw_Customer 이다.
CREATE VIEW vw_Customer AS SELECT * FROM Customer WHERE Address LIKE '%대한민국%';
ex code
Orders 테이블에 고객이름과 도서이름을 바로 확인할 수 있는 뷰를 생성한 후, "김연아" 고객이 구입한 도서의 주문번호, 도서이름, 주문액을 보이시오
CREATE VIEW vw_Orders AS SELECT OrderNo, BookName, Price FROM Orders, Book WHERE Orders.BookNo = Book.BookNo;
SELECT * FROM vw_Orders WHERE CustomerName = '김연아';

2. 인덱스의 개념과 특징
- 인덱스는 테이블의 특정 컬럼에 대해 정렬된 상태로 저장된 자료구조
- 인덱스는 테이블의 특정 컬럼에 대한 검색 속도를 높이기 위해 사용되는 자료구조
- 인덱스는 테이블에서 한 개 이상의 속성을 이용해 생성함
- 저장된 값들은 테이블의 부분집합이 됨

- 인덱스의 종류
-- B-Tree 인덱스 : 기본적인 인덱스로 하나의 리프 노드는 하나의 데이터에 대응 
ex code 
CREATE INDEX idx_BookName ON Book(key1);
-- IOT (Index Organized Table) 인덱스 : 비 트리 구조로 키 값이 정렬되면서 인덱스 리프 노드에 실제 데이터가 같이 저장되는 테이블
ex code
CREATE INDEX T (key1 NUMBER, BDATA VARCHAR2(10)) ORGANIZATION INDEX;
-- Bitmap Index : 비트맵을 사용해 하나의 엔트리가 여러 행을 가리킬 수 있도록 생성
ex code
CREATE BITMAP INDEX idx_BookName ON Book(BookNumber);
-- Function-Base Index : 행과 열에 대한 함수의 결과를 저장한 인덱스

인덱스의 생성
- 인덱스는 WHERE 절에 자주 사용되는 속성이어야 함
- 인덱스는 조인에 자주 사용되는 속성이어야함 
- 단일 테이블에 인덱스가 많으면 속도가 느려질수 있음 테이블당 보통 4~5 개 정도 권장
- 속성이 가공되는 경우 사용하지 않음
- 속성의 선택도가 낮을 때 유리함 (속성의 모든 값이 다른 경우)

-인덱스 생성
CREATE INDEX 인덱스이름 ON 테이블이름(속성1, 속성2, ...);
-인덱스 삭제
DROP INDEX 인덱스이름;
-UNIQUE 인덱스
CREATE UNIQUE INDEX 인덱스이름 ON 테이블이름(속성1, 속성2, ...);
(중복값을 허용하지 않으므로 해당 컬럼에 INSERT 될 때 같은 값이 들어오게 되면 에러 발생)

EX CODE
Book 테이블에서 BookName 열을 대상으로 비 클러스터 인덱스 ix_Book 을 생성
CREATE INDEX ix_Book ON Book(BookName);
EX CODE
Book 테이블에서 publisher, price 열을 대상으로 인덱스 ix_Book2 를 생성
CREATE INDEX ix_Book2 ON Book(publisher, price);


보안과 권한 관리
- 데이터베이스 관리 업무
-- 서비스 관리 
-- 점검 및 모니터링
-- 장애 대처
-- 백업과 복원
-- 사용자 관리 및 권한 관리
-- 시스템 데이터베이스 관리
-- 사용자 데이터베이스 관리 
-- 데이터베이스 저장 공간 관리
-- 인덱스 관리
-- 로그인 사용자 관리
-- 권한 관리

- 데이터베이스 보안
1- 물리적 환경에 대한 보안
1-1 자연 재해 처럼 디비에 물리적 손실을 발생시키는 위험으로 부터 데이터베이스 보호
2- 권한 관리를 통한 보안
2-1 접근이 허락된 사용자만 권한 내에서 디비를 사용해 보호
2-2 계정이 발급된 사용자만 디비에 접근할수 있도록 통제\
2-3- 사용자 별로 사용 범위와 수행 가능한 작업 내용을 제한
3- 운영관리를 통한 보안
3-1 접근이 허락된 사용자가 권한 내에서 디비를 사용하는 동안 데이터 무결성을 유지하도록 제약조건을 정의하고 위반하지 않도록 통제

DCL (Data Control Language)
- 데이터베이스에 접근하고 객체를 사용할 수 있는 권한을 부여하거나 회수하는 명령어
- GRANT : 권한 부여
- REVOKE : 권한 회수

신규 로그인 사용자 계정 생성
CREATE USER 사용자이름 IDENTIFIED BY 비밀번호 DEFAULT TABLESPACE 테이블 스페이스명 
사용자 계정 설정 변경하기
ALTER USER 사용자이름 IDENTIFIED BY 비밀번호
사용자 계정 삭제하기 
DROP USER 사용자이름 CASCADE

권한 부여(Grant)
1- PUBLIC(모든 사용자)에게 SELECT 권한 부여
2- WITH GRANT OPTION
2-1 사용자가 자신이 부여받은 권한을 다른 사용자에게도 부여할 수 있도록함
ex code
고객 테이블에 대한 검색 권한을 사용자 Hong 에게 부여
GRANT SELECT ON 고객 TO Hong;
ex code
고객 테이블에 삽입과 삭제 권한을 모든 사용자에게 부여
GRANT INSERT, DELETE ON 고객 TO PUBLIC;

권한 취소(Revoke)
1- REVOKE SELECT ON 고객 FROM Hong CASCDE;
2- REMOVE SELECT ON 고객 FROM Hong RESTRICT;

역할(ROLE)
1- 데이터 베이스 객체에 대한 권한을 모아둔 집합
역할 생성
CREATE ROLE 역할이름;
역할 제거
DROP ROLE 역할 이름
역할에 권한 부여
GRANT 권한 ON 객체 TO 역할이름;
역할에 권한 취소
REVOKE 권한 ON 객체 FROM 역할이름;
사용자에게 역할 부여
GRANT 역할이름 TO 사용자이름;



백업과 복원
1- 백업 : 데이터베이스에서 예상치못한 장애에 대비해 디비를 복제해 보관하는 작업
2- 복원 :  장애가 발생해 운영중인 데이터 손상이 발생시 기존에 복사해둔 백업파일을 사용해 원래대로 되돌려놓는 작업
1-1 백업의 종류
1-1-1 전체 백업,차등 백업, 트랜잭션 로그 백업

오라클 백업 방법
1- 물리적 백업 
1-1 오라클 디비를 구동하기 위해 필요한 모든 파일을 물리적으로 복사하는 방법
1-1-1 콜드 ㅂ개업: 데이터베이스를 셧다운한 후 백업을 진행하는 방법
1-1-2 핫 백업: 데이터베이스를 셧다운하지 않고 백업을 진행하는 방법
2- 논리적 백업

복구의 개념 
1- 데이터베이스에 이상이 생겨 시스템 정상작동이 불가능할 ㅈ경우 백업한 자료를 이용해 장애발생시점까지의 데이터를 복구하거나 일정 시간을 기준으로 디비 운용시점을 돌려놓으려 하는 작업





================================================================

2023 데이터통신개론 

- 정보통신과 데이터 통신
-- 정보통신: 정보를 주고 받는 통신
-- 데이터 통신: 데이터를 주고 받는 통신
-- 원격 통신: 물리적으로 떨어져 있는 두 장치 간의 통신

- 통신의 역사
-- 원시시대의 통신: 화음, 손짓, 신호등
-- 언어의 발달: 언어를 통한 통신
-- 문자의 발달: 문자를 통한 통신
-- 원격통신: 멀리 있는 사람과의 통신 (봉화, 세마포르)
-- 운송의 발달: 운송 수단을 통한 통신 (비둘기, 역마, 기차)
-- 전기통신의 시작: 전기를 통한 통신 (모오스 부호)
-- 인쇄전기통신의 발달: 인쇄를 통한 통신 (인쇄기, 텔레그래피)
-- 무선전기통신의 발달: 무선을 통한 통신 (라디오, 무선전화)

- 컴퓨터의 발전
-- 컴퓨터의 세대별 분류
--- 1세대 컴퓨터: 진공관을 사용한 컴퓨터
--- 2세대 컴퓨터: 트랜지스터를 사용한 컴퓨터
--- 3세대 컴퓨터: 집적회로를 사용한 컴퓨터
--- 4세대 컴퓨터: 초중고속 연산을 지원하는 컴퓨터
--- 5세대 컴퓨터: 인공지능을 지원하는 컴퓨터

- 데이터 통신의 개념
-- 데이터 통신: 데이터를 주고 받는 통신
-- 데이터 통신의 특징
--- 데이터 통신은 정보 통신의 일종

- 컴퓨터 종류
-- 데스크탑 컴퓨터: 개인용 컴퓨터
-- 노트북 컴퓨터: 개인용 컴퓨터
-- 서버 컴퓨터: 서버용 컴퓨터
-- 스마트폰: 개인용 컴퓨터
-- 태블릿 컴퓨터: 개인용 컴퓨터
-- 스마트워치: 개인용 컴퓨터
-- Microcomputer: 개인용 컴퓨터
-- Mini Computer: 서버용 컴퓨터
-- Mainframe Computer: 서버용 컴퓨터
-- Super Computer: 서버용 컴퓨터

- 데이터통신의 발전
-- SAGE 시스템: 미국의 항공전투기의 제어를 위한 컴퓨터 통신 시스템
-- SABRE 시스템: 미국의 항공예약 시스템
-- ARPANET: 미국의 국방부가 개발한 컴퓨터 네트워크 (최초의 패킷교환망 유선망)
-- ALOHA 시스템: 미국의 무선망 (최초의 패킷교환망 무선망)
-- SNA: IBM 사가 개발한 컴퓨터간 접속 표준

- 정보통신 기술
-- 정보표현의 기술, 정보처리의 기술, 정보저장의 기술, 정보전송의 기술
-- 인간의 감정, 사상, 지식등의 정보를 서로 교환하는데있어서 시간적,공간적 제약을 극복하고자하는 모든기술

- 5감 통신의 가능성
-- 시각감: 영상통신
-- 청각감: 음성통신
-- 미각감: 음식통신
-- 후각감: 향기통신
-- 촉각감: 터치통신

- 데이터 통신 시스템의 5가지 구성 요소
-- 송신기, 수신기, 메시지, 전송매체, 프로토콜

- 데이터 처리 방식
-- 데이터 처리 방식의 분류
--- 일괄처리: 데이터를 일정한 시간 간격으로 일괄적으로 처리하는 방식
--- 온라인: 데이터를 실시간으로 처리하는 방식
--- 분산처리: 데이터를 여러 대의 컴퓨터에 분산하여 처리하는 방식

- 데이터 전송계
-- 단말장치,전송회선,통신제어장치
-- 단말장치: DTE (Data Terminal Equipment) 데이터 터미널 장치, 입출력 기능, 전송제어기능, 기억기능 등을 수행
-- 단말장치의 구성: 입출력 장치와 전송제어 장치로 구성
-- 전송제어 장치: Transmission Control Unit, 데이터 전송 시에 발생하는 오류를 검출 혹은 정정하는 장치

- 신호 변환 장치 DCE (Data Circuit-terminating Equipment), 데이터를 전송에 적합한 신호로 변환하는 장치
-- DCE의 구성: 데이터 전송 회선과 전송제어 장치로 구성
-- 신호 변환 장치 DSU / CSU : 모뎀: Modem, 데이터를 전송에 적합한 신호로 변환하는 장치
-- 통신 제어 장치
-- 통신 소프트웨어: 통신 제어 장치의 기능을 소프트웨어로 구현한 것

- 네트워크의 필요성 및 정의
-- 네트워크의 필요성
--- 네트워크의 필요성: 네트워크를 통해 정보를 공유하고, 정보를 효율적으로 관리할 수 있음
-- 네트워크의 정의
--- 네트워크의 정의: 두 대 이상의 컴퓨터가 연결되어 정보를 교환할 수 있는 시스템
-- 거리에 따른 분류: LAN, MAN, WAN
--- 근거리 통신망: LAN (Local Area Network)
--- 광역 통신망: WAN 공중망 (통신 사업자가 구축한 망을 임대해 사용)

- 프로토콜
-- 프로토콜의 정의
--- 프로토콜의 정의: 컴퓨터 간의 통신을 위한 표준 규약
-- 프로토콜의 종류
--- 프로토콜의 종류: TCP/IP, OSI 7계층 모델
-- 프로토콜의 주요 요소: 구분, 의미, 타이밍
-- 프로토콜의 주요 기능: 캡슐화, 흐름제어, 오류제어, 동기화, 경로지정
--- 캡슐화: 주소나 오류검출 부호 등과 같은 프로토콜 제어정보를 부가하는 것, 보통 헤더라고 부름


- OSI 7 Layer model
-- OSI 7 Layer model의 정의
--- OSI 7 Layer model의 정의: 국제표준화기구에서 개발한 통신 프로토콜의 7계층 모델
-- OSI 7 Layer model의 구성
--- OSI 7 Layer model의 구성: 물리계층, 데이터링크계층, 네트워크계층, 전송계층, 세션계층, 표현계층, 응용계층
-- OSI 7 Layer model의 특징
--- OSI 7 Layer model의 특징: 계층화된 구조, 계층간의 독립성, 계층간의 상호작용, 계층간의 통신은 프로토콜을 통해 이루어짐

1,2,3 정보의 전송 기능 담당, 실제로 데이터가 공간을 이동하는데 관련된 기능을 수행
-1 물리 계층 (Physical Layer) 주요기능 : 물리적인 전송로를 제공
-2 데이터 링크 계층 (Data Link Layer) 주요기능 : 인접 노드 사이의 데이터 전송 기능 수행
-3 네트워크 계층 (Network Layer) 주요기능 : 호스트 간의 데이터 전송 기능, 데이터의 전송 경로 설정

4 상,하위 계층을 연결하는 기능
-4 전송 계층 (Transport Layer) 주요기능 : 프로세스와 프로세스 간의 전달

5,6,7 정보의 처리 기능 담당, 실제로 데이터가 공간을 이동하는데 관련된 기능을 수행
-5 세션 계층 (Session Layer) 주요기능 : 네트워크의 대화조정, 동기화 지점 설정
-6 표현 계층 (Presentation Layer) 주요기능 : 데이터의 표현을 공통된 형식으로 변환, 압축, 암후화 기능
-7 응용 계층 (Application Layer) 주요기능 : 파일 전송이나 이메일과 같은 End-user service 제공

- 계층화 구조와 캡슐화
-- 계층화 구조와 캡슐화의 정의
--- 계층화 구조와 캡슐화의 정의: 계층화 구조는 프로토콜을 계층으로 나누어 설계한 것, 캡슐화는 프로토콜의 헤더를 추가하는 것
-- 계층화 구조와 캡슐화의 특징
--- 계층화 구조와 캡슐화의 특징: 계층화 구조는 계층간의 독립성을 보장, 계층간의 통신은 프로토콜을 통해 이루어짐, 캡슐화는 프로토콜의 헤더를 추가함으로써 프로토콜의 기능을 수행할 수 있음


- OSI 모델의 계층간 상호 작용
-- 중간 노드들은 3계층까지만 동작
-- 대등-대-대등 프로세스 (peer-to-peer process)


- 프로토콜 데이터 단위 (PDU)
-- 계층
Media Layers
--- 물리계층: 비트
--- 데이터링크계층: 프레임
--- 네트워크계층: 패킷/데이터그램

--- 전송계층: 세그먼트

Host Layers
--- 세션계층: 메시지
--- 표현계층: 메시지
--- 응용계층: 메시지


데이터통신의 목적
-정보를 한 지점에서 다른 지점까지 정확하게 전달하는것 

데이터: 단편적인 사실이나 자료의 단순한 나열
정보: 데이터를 해석하여 의미를 부여한 것
신호: 정보를 전달하기 위해 전기적, 기계적, 물리적인 형태로 변환한 것


아날로그: 비슷하다 라는 말에서 유래 (연속적인 값을 가지는 데이터)
- 아날로그 데이터 : 목소리, 화상, 음향, 영상 등
디지털: 손가락이라는뜻을가진 digit 에서 유래 (불연속적인 값을 가지는 데이터, 이산적)
- 디지털 데이터 : 문자, 숫자, 컴퓨터 데이터 등

아날로그 신호 : 연속적인 파형, 시간에 따라 연속적으로 변화

디지털 신호 : 이산적인 파형, 시간에 따라 변화하는 값이 끊어져 있음

디지털 전송 (기저대역 전송)
- 아날로그 데이터를 디지털 신호로 변환하는 과정을 아날로그-디지털 변환 (PCM A/D 변환)이라고 함
- 디지털 데이터를 디지털 신호로 전송하는것을 라인 코딩이라고 함

아날로그 전송 (변조)
- 디지털 데이터를 아날로그 신호로 변환하는 과정을 디지털-아날로그 변환 (D/A 변환)이라고 함
- 아날로그 데이터를 아날로그 신호로 전송하는것을 아날로그 변조(아날로그 통신)


-가까운곳에 보내는것을 디지털 신호가 적합
-멀리 보내는것을 아날로그 전송이 적합


디지털 전송의 장점
1. 멀티미디어 전송에 적합
2. 경제적인 전송
3. 고품질 전송
단점
-아날로그 전송에 비해 대역폭이 증가됨


PCM 의 3단계 변환 과정
1- 표본화(샘플링)
1-2- 아날로그 신호를 왜곡없이 재구성하기위해서는 원래 신호의 최고 주파수보다 2배이상 샘플링하여야함
ex 최대 주파수가 3000Hz 인 음성은 초당 6000Hz 이상의 샘플링 주파수가 필요
2- 양자화
2-1- 이산값으로 계량화
3- 부호화
3-1- 이산값을 이진수로 변환


눈 패턴(아이 패턴)
- 눈 패턴은 샘플링 주파수가 2배가 되는 곳에서 발생하는 현상으로, 샘플링 주파수가 2배가 되는 곳에서는 샘플링이 정확히 이루어지지 않아서 발생
- 눈 패턴을 제거하기 위해서는 샘플링 주파수가 2배가 되는 곳에서는 샘플링을 하지 않고, 샘플링 주파수가 2배가 되는 곳의 샘플링을 2개의 샘플링으로 대체하는 방법을 사용


라인 코딩: 디지털 데이터를 디지털 신호로 변환하는 과정
- 라인 코딩(기저대역전송)
-- 변조를 하지않고 그대로 전송
-- 동기화와 직류 제거가 필요
-- 단극형, 극형 
- NRZ-L(Non Return to Zero Level)
- NRZ-I(Non Return to Zero Invert)
- RZ( Return to Zero)
- Manchester
-- 매 비트 구간의 중앙에서 항상 변화
- Differential Manchester
-- 매 비트 구간의 중앙에서 항상 변화
-- 비트 구간의 시작점에서 비트 1은 변화 비트 0은 무변화
- Biphase
- 양극형
- AMI(Amplitude Modulation Invert)


변조 (Modulation)
- 데이터를 사인파에 실어서 전송

- 아날로그 변조 : 아날로그 데이터를 아날로그 신호
-- 연속적인 사인파(아날로그 변조)
-- 불연속적인 사인파(펄스 변조)
-- 반송파인 사인파의 3가지 요소인 진폭, 주파수, 위상에 데이터를 실어서 전송
-- 진폭 변조(Amplitude Modulation)
--- 정보 신호의 크기에따라 반송파의 진폭을 변화시킴
-- 주파수 변조(Frequency Modulation)
--- 정보 신호의 크기에따라 반송파의 주파수를 변화시킴
-- 위상 변조(Phase Modulation)
--- 정보 신호의 크기에 따라 반송파의 위상을 변화시킴

- 펄습 변조(Pulse Modulation)
-- 반송파로 펄스를 사용하는 변조 방식이며 펄스의 진폭, 위치, 폭을 변화시킴
-- 펄스 진폭 변조 (Pulse Amplitude Modulation)
--- 표본화된 값을 신호의 진폭에 따라 비례하는 펄스로 바꿔 전송
-- 펄스 위치 변조 (Pulse Position Modulation)
--- 표본화된 값을 신호의 진폭에 따라 비례하는 펄스로 바꿔 전송
-- 펄스 폭 변조 (Pulse Width Modulation)


- 디지털 변조 : 디지털 데이터를 아날로그 신호로 변환
-- ASK(Amplitude Shift Keying)
--- 디지털 데이터 0 과 1 에 반송파의 서로 다른 진폭을 대응시킴
-- FSK(Frequency Shift Keying)
-- PSK(Phase Shift Keying)
--- 직전 신호의 위상을 기준으로 비트 1 은 180 도 바꾸고 비트 0 은 무변화 
--- 성능은 떨어지지만 위상 동기 회로가 필요하지 않음
--- 구하는 수식 : 2파이/M 
-- QPSK(Quadrature Phase Shift Keying)
--- 위상을 90도씩 바꿈
--- I 채널과 Q 채널 두개가있음 
--- 피변조파의 크기는 일정
-- QAM(Quadrature Amplitude Modulation)
--- 진폭 2가지, 위상 4가지: 8-QAM
--- 정보에 따라 반송파의 진폭과 위상을 동시에 변화시킴
-- MSK(Minimum Shift Keying)
--- 위상 편이 변조와 주파수 편이 변조의 합성으로 cpfsk 라고도 함
--- 비동기 검파가 가능하다
--- 장점: 일정한 포락선, 위상이 연속, 대역폭이 좁아짐 


동기 검파와 비동기 검파 
- 검파: 수신 측에 도착한 변조파로부터 원 신호를 복원하는 것(복조)
- 비동기 검파: 수신 신호의 반송파 위상정보를 전혀 이용하지 않고 검파하는 방식
- 동기 검파: 수신 신호로부터 반송파의 주파수와 위상 정보를 검출해 이 위상 정보를 이용하여 복조하는 방식






================================================================

2023 인터넷기반기술 XML 
extensible markup language 
- XML의 정의
-- XML의 정의: 데이터를 저장하고, 전송하고, 처리하기 위한 표준 언어
--- 문서 전체에 포함된 정보가 아닌 어떤 태그에 관련된 정보를 기반으로 함
-- 특징: 개발자는 여러가지 응용프로그램으로부터 구조화된 데이터를 로컬 컴퓨팅 및 프레젠테이션을 위해 데스크톱으로 전달할 수 있음, XML 을 사용해 특정 응용프로그램에 대한 독특한 데이터 형식을 만들 수 있음, 서버 간의 구조화된 데이터 전송을 위한 이상적인 형식임

- XML 탄생 전: HTML 과 SGML 과 같은 언어들이 있었음
-- HTML: 웹페이지를 만들기 위한 언어
-- SGML: 문서를 만들기 위한 언어

- XML 의 효과
-- 통합의 필요성 대두
--- 기업간 거래시 해당 정보를 교환하기 위해 공통의 언어를 제공함으로 앱 과정을 통합하고 단순화할 필요성이 대두되고있음
--- 공급 체인은 자동화되고 모든 거래 파트너로 확장될 수 있음
--- 거래 파트너들이 연결되기때문에 고객 입장에선 보다 풍부한 정보를 통해 구매결정을 내릴 수 있음
-- 데이터베이스 지원
--- 사용자가 구조화된 db 를 뜻대로 조작 가능
-- 정확한 정보 검색 지원
--- 검색엔진이 xml 을 이용해 정보를 더 정확하게 검색할 수 있음(검색엔진의 효율성을 높이고 불필요한 접속으로 인한 웹 서버의 부담을 감소시키는 효과를 가져옴)
-- 비즈니스 데이터 교환
--- xml 을 이용해 비즈니스 데이터를 교환할 수 있음
-- 웹 서비스 지원
--- 웹 서비스는 xml 을 이용해 웹 서버와 클라이언트 간의 통신을 가능하게 함


- XML 문서의 종류
-- 첫 시작은 <?xml version="1.0" encoding="UTF-8"?> 시작함

--EBNF (Extended Backus-Naur Form) : 문법을 표현하는 방법
--- S 는 공백을 뜻함
--- 기호 ::= 표현식 
EX CODE
Char a ~ z 까지 한 문자를 갖는 표현식
Char ::= [a-z]
EX CODE
VersionNum 이 0~9 까지 한 문자를 갖는 표현식
VersionNum ::= [0-9]
EX CODE
World 가 version 이라는 고정 문자열을 갖는 표현식
World ::= version

-- 표현식
A? : A가 0번 또는 1번 나타남 (A가 있을 수도 있고 없을 수도 있음)
A* : A가 0번 이상 나타남 (A가 0번 이상 나타남) 여러개가 와도 됨
A+ : A가 1번 이상 나타남 (A가 1번 이상 나타남) 한개 이상이 와야함
A|B : A 또는 B가 나타남 (A 또는 B가 나타남)


-- DTD (Document Type Definition) : 문서의 구조를 정의하는 방법
-- XML Schema : 문서의 구조를 정의하는 방법


- XML 문서의 구조
-- Document(문서) ::= Prolog(서두)Element(엘리먼트) Misc(기타)*
--- 서두 1개 필수 , 엘리먼트 1개 필수, 기타 0개 or 여러개

PORT=4000
MONGODB_URI=mongodb+srv://foodie_doodie:7NDC6bfN1oViAvbd@foodiedoodie.w0xiwx7.mongodb.net/FoodieDoodie?retryWrites=true&w=majority


- XML 선언 문법 : 현재 문서가 XML 문서임을 선언하는 문법
-- 첫줄 : <?xml version="1.0" encoding="UTF-8"?>
--- 주석을 첫줄에 넣어도 안됨, 공백을 넣어도 안됨
--- version : 문서의 버전을 나타냄, 반드시 작성해야함
--- encoding : 문서의 인코딩 방식을 나타냄, 디폴트 유니코드 인코딩 방식은 UTF-8
--- standalone : 문서가 독립적으로 사용되는지를 나타냄, 디폴트 값은 no


- 인코딩 및 유니코드
-- 인코딩 : 문자를 컴퓨터가 이해할 수 있는 0과 1로 변환하는 과정

- 한국 표준 문자 집합 (KSC5601) : 한글 2바이트, 영어 1바이트
- EUC-KR 인코딩 : 한글 2바이트, 영어 1바이트
= 둘의 차이 점: 백슬래시를 원화 기호로 부르는가의 차이

- 유니코드 : 기존 언어의 인코딩 체계를 모두 포합할수있도록 고안된 거대한 문자 집합
-- 유니코드의 특징
--- 2바이트로 표현되는 문자 집합

- XML 권고안
-- 모든 xml 문서는 유니코드 인코딩 방식 UTF-8 인코딩 방식으로 저장할것을 기본으로함


- 엘리먼트 작성 문법
-- 엘리먼트 : 문서의 구성요소를 나타내는 태그
-- 엘리먼트 특징
--- 엘리먼트는 시작 태그와 종료 태그로 구성됨
--- 시작 태그와 종료 태그는 반드시 같은 이름을 가져야함
--- 부가적인 정보를 나타내는 속성을 가질 수 있다
--- 시작 태그와 종료 태그 사이에는 내용이 들어갈 수 있다


- 잘못된 태그의 예
-- 첫 글자는 숫자로 이용할수없음
-- 공백을 이용할수없음
-- _ , - , . , : 이외의 특수 문자는 사용할수없음


XML 1.0 권고안의 마크업
- xml 선언 : <?xml version="1.0" encoding="UTF-8"?>
- 문서 유형 선언 : <!DOCTYPE booklist SYSTEM "bml.dtd"?>
- 주석 : <!-- 주석 내용 -->
- 시작 태그 및 종료 태그 : <booklist> </booklist>
- 빈 엘리먼트 태그 : <image src=""/>
- 엔티티 참조 : DTD 에 정의되어있는 엔티티 참조
- 문자 참조 : 유니코드 문자 참조
- CDATA 섹션 : <![CDATA[ 문자 데이터 ]]> // Character data
- 프로세싱 지시자 : <?xml-stylesheet type="text/xsl" href="bml.xsl"?>
- 최상위 공백 문자열 : XML 문서 구성요소 중 루트 엘리먼트 외부에있는 공백 문자열
- text 선언 : <?xml version="1.0" encoding="UTF-8"?>

- 문자 데이터 내에는 & 문자와 < 문자를 사용할 수 없음


엔티티 참조
- 자주 쓰이는 내용을 엔티티로 정의함
- xml 문서에서 엔티티로 정의된 내용과 동일한 내용이 작성되어야할 부분에 엔티티 참조를 사용함
ex code DTD 문서에서 엔티티 정의
<!ENTITY KR "대한민국">

문자 참조 : 문자 집합 코드표상에 언급되어있는 코드값을 직접 사용해 문자를 나타낸것

PCDATA (Parsed Character Data) : 문자 데이터를 의미함
- 대부분의 문자 데이터
- xml 파서가 해석하는 데이터

CDATA (Character Data) : 섹션 내에 정의된 문자 데이터
- xml 파서가 해석하지 않는 데이터
- 문법: <![CDATA[ 문자 데이터 ]]>


프로세싱 지시자
ex code 스타일시트
<?xml-stylesheet type="text/xsl" href="bml.xsl"?>

ex code nameprocessor 에 select * from emp 명령 전달
<?nameprocessor SELECT * FROM emp>

ex code myapp1에 parm1="v" parm2="v2" 명령전달
<?myapp1 parm1="v" parm2="v2"?>


타깃 
- 타깃 : 프로세싱 지시자를 처리하는 프로그램
- 태그 이름 작성 규칙과 동일
- 프로세싱 지시자를 처리하는 응용프로그램을 식별하는 역할을 함
- 지시자는 해당 응용프로그램이 어떻게 문서를 처리하는지에대한 내용



DTD: 문서 유형 정의
1- 문서 가독성을 높일 수 있음
2- 문서 교환의 인식성이 높아짐
3- 앱에서 xml 문서를 사용할 경우 해당 문서마다 동일한 규칙을 적용할수있음
4- XML 문서 제작의 효율성이 높아짐

DTD 사용 방법
1- 내부 DTD : 문서 내부에 DTD를 작성하는 방법
1-1 다른 XML 문서에 적용하기에는 좋지 않은 방법임
ex code 
<!DOCTYPE booklist [
  마크업 선언
]>
xml_마크업

2- 외부 DTD : 문서 외부에 DTD를 작성하는 방법
2-1 다른 XML 문서에 적용하기에 좋은 방법임
ex code
DTD file: dtd_file.dtd
<!DOCTYPE root_element [
  마크업 선언
]>
XML FILE: xml_file.xml
<!DOCTYPE root_element SYSTEM "dtd_file.dtd">
xml_마크업

3- 혼합형 DTD
3-1 내부 DTD와 외부 DTD를 혼합하여 사용하는 방법
3-2 DTD 가 중복 정의된 경우 내부 선언이 외부선언보다 우선함
ex code
DTD file: dtd_file.dtd
<!DOCTYPE root_element [
  마크업 선언
]>
XML FILE: xml_file.xml
<!DOCTYPE root_element SYSTEM "dtd_file.dtd">
[ 마크업 선언 ]>
xml_마크업

DTD 구성요소와 사용 예
- 엘리먼트 선언 : <!ELEMENT 엘리먼트 이름 엘리먼트 내용>
- 속성 선언 : <!ATTLIST 엘리먼트 이름 속성 이름 속성 타입 속성 기본값 #REQUIRED>
- 엔티티 선언 : <!ENTITY 엔티티 이름 "엔티티 값">
- 노테이션 선언 : <!NOTATION 노테이션 이름 SYSTEM "노테이션 값">

문서 타입 선언 형식
- 내부 DTD : <!DOCTYPE 엘리먼트 이름 [ DTD 선언 ]>
- 외부 DTD : <!DOCTYPE 엘리먼트 이름 SYSTEM "DTD 파일 이름">
- 혼합형 DTD : <!DOCTYPE 엘리먼트 이름 SYSTEM "DTD 파일 이름" [ DTD 선언 ]>
- DOCTYPE : DTD 문서 정의 키워드
- root_element: XML 문서의 최상위 요소
- source : "SYSTEM" OR "PUBLIC" 키워드 사용 가능
- location : DTD 파일의 위치를 지정
- [internal DTD] : 내부 DTD 선언

DTD 작성 기본 규칙
1- DTD 는 <?xml... ?> 로 xml 선언
2- DTD 는 <!DOCTYPE...> 로 문서 타입 선언
3- DOCTYPE 은 대문자로 작성

콘텐츠 구분
1- 내용 모델
1-1 #PCDATA: 요소는 일반 텍스트만을 포함함
1-2 자식: 요소는 자식 요소를 포함함
1-3 혼합: 일반 텍스트 형태와 자식 요소를 포함함

2- 내용 카테고리
2-1 EMPTY: 요소는 내용을 포함하지 않음
2-2 ANY: 요소는 어떤 내용이라도 포함할 수 있음

자식 요소 선언
- 자식 요소에서 정의할 수 있는 선언자 기호

혼합형 선언을 할 때 주의 사항
1- 문자 데이터 선언과 함게 정의하는 경우 | 기호만 사용해서 선언함
2- 문자 데이터 선언은 반드시 먼저 선언함
3- 혼합 내용의 반복성은 0 번 이상만 정의될 수 있음

ANY 선언 : 요소에 대해 어떤 조건도 정의하지 않음


속성 선언
1- 요소가 정의되고 속성을 정의하여 사용함
2- 요소와 관련된 속성 이름, 속성 타입, 속성 기본값 등을 정의해 선언함
ex CODE
<!ATTLIST 엘리먼트 이름 속성 이름 속성 타입 속성 기본값 #REQUIRED>

속성_기본값
1- 초깃값을 선언하거나 , #FIXED, #IMPLIED, #REQUIRED 키워드를 사용함
2- #FIXED : 속성의 기본값을 선언함
3- #IMPLIED : 속성의 기본값을 선언하지 않음
4- #REQUIRED : 속성이 반드시 명시적으로 사용이되어야함

속성 타입
1- 열거형 : 속성 값이 특정한 값들 중 하나로 제한됨
2- 문자열 : 속성 값이 문자열로 제한됨
3- 토큰화된 타입 : 속성 값이 공백으로 구분된 토큰으로 제한됨
ex code
ID 타입 사용
<!ATTLIST 엘리먼트 이름 속성 이름 ID #IMPLIED>

-IDREF 타입 사용 (ID 속성 타입으로 선언된 속성 값 중 하나를 가짐)
-IDREFS 타입 사용 (ID 속성 타입으로 선언된 속성 값들을 가짐)
-NMTOKENS 타입 사용 (공백으로 구분된 토큰들을 가짐)


개체 정의
1- 개체 정의 형식
<!ENTITY 개체 이름 "개체 값">
2- 개체 참조 형식 
&개체 이름;

3- 문자 개체 
- 문자 단위의 개체 : &lt; &gt; &amp; &quot; &apos;

개체
1- 일반 개체 : 개체 이름과 개체 값이 일치함
2- 파라미터 개체 : 개체 이름과 개체 값이 일치하지 않음








================================================================

2023 웹기반시스템과S/W활용

WBI (Web Based Instruction) : 웹의 등장과 함께 부각된 새로운 교수학습 방법으로 온라인 형태의 교수학습방법

웹기반교육의 특징
- 웹기반교육의 특징
-- 학습자 상호 간이나 학습자와 교수자 간의 상호작용이 가능
-- 멀티미디어를 제공함 : 오디오, 비디오, 애니메이션, 텍스트 등
-- 개방적임 : 학습자가 언제 어디서든지 학습할 수 있음
-- 온라인 검색이 가능함 : 학습자가 원하는 정보를 검색할 수 있음
-- 정보나 자료를 수시로 수정및 보완이 가능: HTML 을 이용해 웹페이지를 만들면 수정이 쉬움
-- 학습자는 최신의 정보를 이용하고 정보를 공유할수있음
-- 호환성이 뛰어남
-- 이용하기가 쉬움


- 웹 기반교육과 유사한 용어
-- Educational Technology : 교육과정에 정보기술을 적용하는 것
-- e-Learning : 웹 기반 교육
-- m-Learning : 모바일 기기를 이용한 교육
-- Blended Learning : 온라인과 오프라인을 결합한 교육
-- Distance Learning : 원격으로 교육을 제공하는 것
-- Virtual Learning Environment : 가상의 학습환경
-- Smart Learning : 지능형 학습
-- Online Learning : 온라인으로 교육을 제공하는 것
-- Web Based Learning : 웹 기반 교육
-- EdTech : 교육과정에 정보기술을 적용하는 것
-- Cyber Learning : 인터넷을 이용한 학습


- 웹기반교육과 ict 환경
-- 웹기반교육은 ict 환경에서 가능한 교육방법임
-- ict 환경은 웹기반교육을 가능하게 함
-- ict 환경은 웹기반교육을 효과적으로 이용할 수 있도록 지원함


- 디지털 컨버전스
-- 디지털 컨버전스: 디지털 컨버전스란 디지털 기술을 이용해 기존의 비디지털 기술을 디지털 기술로 변환하는 것을 말함


- STEAM: 전통적인 미디어와 IT 기술의 융합
-- STEAM: Science, Technology, Engineering, Art, Mathematics


- 웨어러블 사회 iot
-- 웨어러블 사회: 웨어러블 사회란 사람들이 웨어러블 기기를 이용해 정보를 수집하고, 정보를 공유하고, 정보를 분석하고, 정보를 활용하는 사회를 말함
-- iot: iot란 사물인터넷을 말함


- 유비쿼터스 사회
-- 유비쿼터스 사회: 유비쿼터스 사회란 사람들이 어디에 있든지 정보를 얻고, 정보를 공유하고, 정보를 분석하고, 정보를 활용할 수 있는 사회를 말함


- 웹기반교육의 구성요소
-- 교육철학적 특성
-- 웹기반교육의 특성
-- 교수자의 역할에 따른 분류
--- 강의 모형: 교수자가 학습자에게 강의를 진행하는 방식
--- 촉진 모형: 교수자가 학습자에게 학습을 촉진시키는 방식
--- 관리 모형: 교수자가 학습자에게 학습을 관리하는 방식


- 웹기반 교수-학습 체제 설계의 절차적 단계 : 분석 -> 설계 -> 제작 -> 운영 -> 평가


- 컴퓨터시스템의 구성 요소
-- Motherboard : 컴퓨터의 기본적인 구성요소
-- CPU : 컴퓨터의 뇌
-- power supply : 전원 공급 장치
-- cooling fan : 냉각 장치
-- internal speaker : 내장 스피커
-- drive bay : 드라이브 슬롯
-- expansion slot : 확장 슬롯
-- ram : 램
-- network card : 네트워크 카드


- 입력 장치
-- 키보드 : 키보드는 문자, 숫자, 기호 등을 입력하는 장치
-- 마우스 : 마우스는 컴퓨터 화면에서 원하는 위치를 지정하는 장치
-- 스캐너 : 스캐너는 문서나 사진 등을 컴퓨터로 입력하는 장치
-- 터치스크린 : 터치스크린은 손가락으로 화면을 터치하여 입력하는 장치
-- 펜 : 펜은 손가락이 아닌 펜으로 화면을 터치하여 입력하는 장치
-- 마이크 : 마이크는 음성을 입력하는 장치
-- 웹캠 : 웹캠은 영상을 입력하는 장치
-- 디지털 카메라 : 디지털 카메라는 사진을 입력하는 장치
-- 디지털 캠코더 : 디지털 캠코더는 영상을 입력하는 장치
-- 그래픽 태블릿 : 그래픽 태블릿은 손가락으로 화면을 터치하여 입력하는 장치


- 출력 장치
-- 모니터 : 모니터는 컴퓨터 화면을 출력하는 장치
-- 프린터 : 프린터는 문서를 출력하는 장치
-- 스피커 : 스피커는 소리를 출력하는 장치
-- 헤드폰 : 헤드폰은 소리를 출력하는 장치
-- 프로젝터 : 프로젝터는 영상을 출력하는 장치
-- HMD : HMD는 가상현실을 출력하는 장치


- 저장 장치
-- 하드디스크 : 하드디스크는 컴퓨터에 저장된 정보를 저장하는 장치
-- USB 메모리 : USB 메모리는 컴퓨터에 저장된 정보를 저장하는 장치
-- SSD : SSD는 컴퓨터에 저장된 정보를 저장하는 장치
-- CD-ROM : CD-ROM은 컴퓨터에 저장된 정보를 저장하는 장치
-- DVD-ROM : DVD-ROM은 컴퓨터에 저장된 정보를 저장하는 장치
-- NetworkAttachedStorage: 양쪽 화면에 나타나는 약간의 위치 차이에의해 3차원 물체를 보는것과같은 느낌
-- Remote Storage : 원격 저장소는 컴퓨터에 저장된 정보를 저장하는 장치


- 광저장장치 ODD : Optical Disk Drive
-- CD -> DVD -> BD

- 저장원리 및 단위
-- kilobit : 1,000 bit
-- ASCII : 정보 교환을 위한 미국 표준 코드


- 연결장치
-- USB : USB는 컴퓨터와 외부 장치를 연결하는 장치
-- SCSI : SCSI는 컴퓨터와 외부 장치를 연결하는 장치
-- eSATA : eSATA는 컴퓨터와 외부 장치를 연결하는 장치


- Flipped learning : 학생들이 미리 수업을 듣고, 수업 시간에는 수업 내용을 활용한 실습을 진행하는 학습 방식
-- Flipped learning의 장점
--- 학생들이 수업 시간에 집중할 수 있음
--- 학생들이 수업 시간에 질문을 할 수 있음
--- 학생들이 수업 시간에 실습을 할 수 있음
--- 학생들이 협동 학습을 할 수 있음
--- 학생들이 개별 학습을 할 수 있음
-- Flipped learning의 단점
--- 학생들이 미리 수업을 들어야 함
-- 개발 과정 
--- plan -> record -> share -> change -> group -> regroup -> review -> revise -> repeat


- MOOCs
-- Massive Open Online Courses : 교육자가 온라인으로 강의를 제공하고, 학생들이 온라인으로 강의를 수강하는 교육 방식


- 초거대 AI 
-- 초거대 AI : 인간의 지능을 모방한 인공지능
-- 빅데이터 처리 능력
-- 고도의 처리 능력
-- 실시간 분석

- 생성 AI
-- 새로운 컨텐츠를 생성하는 기능
-- 기존 패턴 및 정보 기반
-- 독특하고 다양한 결과물 생성

- 학습 AI
-- 맞춤형 학습
-- 지능형 튜터링 시스템
-- 예측 분석
-- 자동 평가 및 채점
-- 장점 
--- 효율성 향상 
--- 개인화된 학습 경험
--- 학습자 참여도 향상
--- 데이터 기반의 의사 결정
-- 단점
--- 알고리즘 개발의 편향성과 공평성
--- 윤리 및 개인 정보 보호 문제
--- 기술에 대한 의존성
--- 전문 교육의 필요성


- 4차 산업혁명
-- 4차 산업혁명 : 인공지능, 빅데이터, 사물인터넷, 클라우드 컴퓨팅 등의 기술을 기반으로 새로운 융합 기술을 개발하고, 이를 통해 새로운 가치를 창출하는 혁명
-- 4차 산업혁명의 특징
--- 자율진화, 무인 의사결정, 만물의 데이터화, 실시간 반응

- 4차 산업혁명으로인한 변화 전망
-- 산업구조의 변화
-- 고용구조
-- 삶의 모습과 환경


- 10대 미래유망기술
-- iot 기반 상황 인식형 조광기술
-- 능동제어형 소음 저감 기술
-- ai 팩트 체킹 보조 기술
-- 원전 사고 대응 시스템
-- 비방사성 비파괴 검사 기술
-- 초미세먼지 제거 기술
-- 친환경 녹조-적조 제거 기술
-- 생활폐기물 첨단 분류- 재활용 시스템
-- 환경변화 실시간 입체 관측 기술
-- 미생물 활용 환경복원 기술

- 사람 중심 스마트 사회 구현 10대 미래유망 기술
-- 반응형 주택 기술
-- 라이프로그 개인비서 소프트웨어 기술
-- 커넥티드카 기술
-- 모듈형 대중교통 시스템
-- 무선 전력 전송 기술
-- 스마트 타투 기술
-- 소프트 로봇 기술
-- 스마트 팜 기술
-- 인공지능 보안 기술
-- 혼합 현실 기술

- 제조업 경쟁력 강화를 위한 소재분야 10대 미래유망기술
-- 친환경 바이오플라스틱 필름
-- 손실된 인체감각을 대체하는 기기용 소재
-- 3d 프린팅 인공장기
-- 불이 안나는 고성능 고체전해질
-- 수송용 고속 충-방전이 가능한 배터리
-- 더 이상 무겁지 않은 초경량 수송체
-- 1억도시 이상의 극한의 환경을 견디는 차세대 핵융합 소재
-- 스트레처블 디스플레이
-- 자율적으로 수명을 제어하는 화학소재
-- 완전 직물형 웨어러블 소자


- 혁신적 기술의 확산
-- 휴먼 임파워먼트
-- 초연결에 의한 혁신
-- 환경 리스크 심화
-- 사회 복잡성의 진화
-- 경제 시스템의 재편

- 24개 혁신기술의 기술확산점 도출결화
-- 멀티콥터 드론
-- 실감형 가상-증강 현실
-- 스마트 팩토리
-- 만물인터넷
-- 3d 프린팅
-- 빅데이터 활용 개인 맞춤형 의료
-- 스마트 그리드
-- 초고용량 배터리
-- 극한 성능용 탄소섬유 복합 재료
-- 롤러블 디스플레이
-- 희소금속 리사이클링
-- 웨어러블형 보조 로봇
-- 자율주행 자동차
-- 포스트 실리콘 반도체
-- 인지 컴퓨팅
-- 이산화 탄소 포집 저장
-- 유전자 치료
-- 줄기세포
-- 지능형 로봇
-- 인공 장기
-- 양자 컴퓨팅
-- 뇌-컴퓨터-인터페이스
-- 인공광합성
-- 초고속 튜브 트레인


- 5대 글로벌 메가 트렌드
-- 세계 경제력의 변화
-- 기후 변화와 자원 부족
-- 기술 혁신
-- 인구와 사회 변화
-- 급속한 도시화


- 10대 글로벌 기술 트렌드
-- 인공지능 및 기계학습
-- 5g 네트워크
-- 엣지 컴퓨팅: 데이터는 중앙 지붖ㅇ식 위치가아닌 네트워크 엣지(가장자리)에서 처리됨
-- 가상 및 증강 현실
-- 양자 컴퓨팅
-- 블록체인 기술
-- 로봇 공학 및 자동화
-- 사물 인터넷
-- 맞춤형 건강 및 웰빙 기술



웹기반교육 컨텐츠 개발의 개요
1 전체 개발 일정 및 프로세스
-- 1.분석 - 2.설계 - 3.개발 - 4.전달 - 5.유지보수
2 미디어유형에 따른 콘텐츠 유형
-- 저작도구 S 유형 : 교수님 영상과 학습내용이 제공되며 판서 가능
-- 저작도구 I 유형
-- 전자칠판 유형
-- 칠판 유형

3 설계유형에 따른 컨텐츠 유형
-- 사례탐구형
-- 전문가 인터뷰형
-- 시연형
-- 오프라인 특강
-- 과제 크리틱형
-- 시뮬레이션형
-- 키워드형
-- 문제풀이형

4 혼합유형


ChatGPT : 챗봇과 대화를 나누는 GPT-3 모델


================================================================

2023 안드로이드프로그래밍

스마트폰 개발 환경
- 안드로이드 : java, kotlin, c++
-- 개발도구 : 안드로이드 스튜디오
- 아이폰: objective C
-- 개발도구 : Xcode
- 윈도우폰: C#, VB.NET
-- 개발도구 : Visual Studio


- 안드로이드 버전
-- 알파 : 1.0 , API 레벨 1, 발표일자 2008년 09월 
-- 베타 : 1.1 , API 레벨 2, 발표일자 2009년 02월
-- 컵케이크 : 1.5 , API 레벨 3, 발표일자 2009년 10월
-- 도넛 : 1.6 , API 레벨 4, 발표일자 2010년 02월
-- 이클레어 : 2.0 , API 레벨 5, 발표일자 2010년 10월
-- 프로요거트 : 2.2 , API 레벨 8, 발표일자 2010년 11월
-- 진저브레드 : 2.3 , API 레벨 9, 발표일자 2011년 02월
-- 허니콤 : 3.0 , API 레벨 11, 발표일자 2011년 02월
-- 아이스크림샌드위치 : 4.0 , API 레벨 14, 발표일자 2011년 10월
-- 젤리빈 : 4.1 , API 레벨 16, 발표일자 2012년 07월
-- 킷캣 : 4.4 , API 레벨 19, 발표일자 2013년 10월
-- 롤리팝 : 5.0 , API 레벨 21, 발표일자 2014년 11월
-- 마시멜로 : 6.0 , API 레벨 23, 발표일자 2015년 10월
-- 누가 : 7.0 , API 레벨 24, 발표일자 2016년 08월
-- 오레오 : 8.0 , API 레벨 26, 발표일자 2017년 08월
-- 파이 : 9.0 , API 레벨 28, 발표일자 2018년 08월

- 안드로이드의 주요한 기능
-- 앱 프레임워크를 통해 제공되는 API 를 사용해 코드를 재사용하고 효율적이고 빠른 앱 개발 가능
-- 모바일 기기에 최적화된 달빅 또는 아트런 타임 제공
-- 2d 그래픽 및 삼차원 그래픽 최적화해 표현
-- 모바일용 디비 SQLite 제공
-- 각종 오디오, 비디오, 및 이미지 형식을 지원
-- 모바일 기기에 내장된 각종 하드웨어 지원
-- 이클립스 또는 안드로이드 스튜디오와 같은 통합 개발 환경 제공

- 안드로이드의 특징
-- 리눅스 기반
-- 자바를 앱 개발 언어 사용
-- 안드로이드 SDK 에서 많은 라이브러리를 포함해 개발이 용이함
-- 오픈소스를 지향하기에 운영체제로부터 관련문서, 개발도구등 거의 모든것을 무료로 사용가능
-- 지속적인 업그레이드 제공

- 안드로이드 구조
-- 응용 프로그램 : 안드로이드 스마트폰에서 사용할 수 있는 일반적인 응용 프로그램
--- 웹 브라우저, 달력, 구글맵, 연락처, 게임 등 사용자 입장에서 가장 많이 사용됨
--- 자바로 제작됨
-- 응용 프로그램 프레임워크 : 안드로이드 응용 프로그램을 개발할 때 사용하는 API
-- 안드로이드 런타임 : 자바 코어 라이브러리와 달빅 가상 머신 or 아트 런타임으로 구성됨
-- 라이브러리:  안드로이드에서 사용되는 여러 시스템 라이브러리
-- 리눅스 커널 : 안드로이드의 핵심 부분으로 안드로이드의 모든 기능을 제공함


- 안드로이드 개발 환경 설치 단계
-- 안드로이드 스튜디오 설치
-- 안드로이드 스튜디오 환경 설정
-- 안드로이드 SDK 업데이트 
-- AVD (Android Virtual Device) 만들기
-- 안드로이드 앱 개발


안드로이드 프로젝트 생성
- create android project
- application name : 프로젝트 이름
- company domain : 회사 도메인
- project location : 프로젝트 위치
- project format : 프로젝트 형식
- minimum sdk : 최소 sdk 버전
- target sdk : 타겟 sdk 버전
- use gradle : gradle 사용 여부
- use kotlin : kotlin 사용 여부
- create activity : 액티비티 생성 여부
- activity name : 액티비티 이름
- layout name : 레이아웃 이름
- activity type : 액티비티 타입
- activity template : 액티비티 템플릿
- create activity : 액티비티 생성 여부


화면 디자인 편집
- activity_main.xml 에서 android.support.constraint.ConstraintLayout 을 RelativeLayout(상대적인 위치에 배치) 으로 변경 


AVD 에서 앱 아이콘 출력
-1- JAVA -> mainActivity 에서 supportActionBar?.setDisplayShowHomeEnabled(true)
        supportActionBar?.setIcon(R.mipmap.ic_launcher) 두줄 추가
-2- manifests 의 AndroidManifest.xml 에 android:theme="@style/Theme.AppCompat.Light.DarkActionBar" 로 수정 후 실행하면 앱 아이콘이 출력됨


AVD 명칭
- 상태 바 : 안드로이드 스마트폰의 상태를 나타내는 바
- 타이틀 바 : 앱의 이름을 나타내는 바
- 네비게이션 바 : 앱의 메뉴를 나타내는 바
- 툴바 : 앱의 기능을 나타내는 바


디자인 속성
<Button
        android:layout_height="wrap_content" // 크기를 내용에 맞추기
        android:layout_width="match_parent" // 가로로 꽉 채우기
        android:id="@+id/button1" // 버튼의 id button1
        android:text="@+string/strBtn1" // 텍스트는 문자열 
        >
        
    </Button>


R 클래스 : 레이아웃 파일에서 사용되는 리소스를 참조하기 위한 클래스

res 폴더 : app 의 리소스를 저장하는 폴더


자바
- 명료한 객체지향언어
- 높은 이식성, 기계에 대한 중립적
- 분산 처리 지원
- 멀티스레드 언어
- 구문이 간결함







```
