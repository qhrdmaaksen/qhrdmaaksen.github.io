---
layout: post
title: "첫 포스팅 테스트중입니다.!"
---

## 민우의 블로그 테스트중입니다

```js
===============install 설정===========
node 설치 후 
node version check 
  in terminal command : node -v

npm 초기화 : npm init

next 설치
  npm i next@9     (@9는 version 을 의미)

package.json 에서 대략적인거 설정하고, test 를 "dev": "next" 변경 

react and react-dom 설치가안되어있다면 npm i react react-dom 으로 설치

pages folder create (반드시 폴더명은 pages 여야한다. 넥스트가 인식한다)
  pages folder 안에 file 들은 pages 가 파일들을 개별적인 page 로 만들어준다 (page component)
    code splitting 으로 만들어준다 

pages folder in create index.js file

npm i antd styled-component @ant-design/icons

npm i styles-components
------------------
코드 통합 ( 깨끗한 코드 및 문법 검사 )
npm i eslint -D
npm i eslint-plugin-import -D
npm i eslint-plugin-react -D
npm i eslint-plugin-react-hooks -D
npm install prettier --save-dev --save-exact

.eslintrc 폴더에 추가 및 셋팅
{
	"parserOptions": {
		"ecmaVersion": 2020, // 버젼
		"sourceType": "module", // 모듈 시스템
		"ecmaFeatures": {
			"jsx": true
		}
	},
	"env": { // 환경
		"browser": true,
		"node": true,
		"es6": true
	},
	"extends": [
		"eslint:recommended", // 규칙을 따른다
		"plugin:react/recommended"
	],
	"plugins": [
		"import",
		"react-hooks"
	],
	"rules": {
	}
}


prettier settings
module.exports =  {
	semi:  true,
	trailingComma:  'all',
	singleQuote:  true,
	printWidth:  100,
	tabWidth:  2,
};
=========================================
1) next.js 역할, settings, page & layout, Link & eslint 
브라우저 : 백엔드간에 요청에 CORS 설정이 필요하다

CSR : 브라우저 프론트 브라우저  백엔드 브라우저 
SSR (서버사이드렌더링) : 브라우저 프론트 백엔드 프론트 브라우저
  로딩을 없애는 이유로 ssr 을 사용하는것도 좋다 (캐싱까지 활용되면 최고)

몽고 db 추천안하는 이유 : 대부분 서비스에는 관계가있다, sql을 사용하는게 좋다. 
  하지만, 관계가없고 데이터가 다른데 하나의 테이블에 들어가야할때엔 사용하기좋다.

next 가 ssr 을 쉽게 해준다.

리액트사용 이유: 고객이 웹 사이트가아니라 모바일 웹을 사용하는것 같은 느낌을 받음
  검색엔진에 나와야한다면, SSR 
    그렇지않다면 REACT


react-router 에서 했던 맵핑을 next 는 자동으로 해준다

pages 하위 folder 를 생성할수있으며, 생성된 폴더(about)에 file 에 접근하려면
  localhost:3000/about/vitamin777 

prop-Types 사용 시 설치 :  npm i prop-types

next.js 는 react 를 사용한 framework 다
  갖춰진건 많지만 코딩의 자유도는 줄어든다
    next 가 해주는 것중 제일 큰 장점은 server side rendering

크게 3 개의 주체
브라우저;
프론트서버;
백엔드서버;데이터베이스;

전통적인 구동방식
browser -> frontend server -> backend server -> data base -> 
- backend server -> frontend server -> browser

SPA 구동방식 ( 사용자가 빠르게 인터렉션을 원할때 ) 
  (data 없이 화면만 받음)js, html, css, img 등을 browser에 뿌려주며, data는 다시 backend server
  - 에서 db -> backend server -> browser 

검색엔진을 위해 서버 사이드 렌더링
  코드 스플릿팅
    첫 방문은 전통적인 구동방식으로 하되, 그 다음 페이지 전환일땐 react 방식으로

next를 사용 유무를 고려해야할것
무 - 어드민 페이지 ( 코드 스플릿팅, 서버사이드 렌더링이 필요없는 경우)
유 - 검색엔진이 필요하고 고객들이 접근하는 페이지

return 안에 들어가는 모든 것들은 node 

next 에는 react 의 hot loader 가 적용이되어있다. (실시간 자동 업데이트 반영)

웹팩은 여러개의 파일을 하나의 js로 합쳐주는 툴임
  next도 webpack을 쓰고 있는데 내부적으로 쓰고 있어서 따로 설정이 없는 것
=================================================
2) antd(css framework) & styled-components, _app.js & Head,
    use the response grid, create login form
      rerendering understand, use dummy data to login, chrome extension,
        create profile page, signup page

next 에는 기본적으로 webpack 이 들어가있다.
  css file 은 import 를 못하며, import 는 js 만 가능하다
    웹팩이 css 를 보는 순간 스타일 태그로 바꿔서 html 에 넣어준다 .

공통된것들은 pages 에 _app.js 에 설정해둔다 
  _app.js 는 pages 들의 완전한 공통 부분이다.

_app.js 가 모든 pages 들의 부모 역할

Head 수정: next 에서 Head component 제공함
  import Head from 'next/head';

next page structure
_document         <DOCUMENT>
_app              <App>
pages             <Page>

node는 elementType, number, string, null 등 모든 것을 넣을 수 있고, 
  elementType에는 컴포넌트만 넣을 수 있다.
    _app.js in code : PropTypes.elementType.isRequired,

antd design 은 직접 site 들어가서 code 보고 적합한걸로 사용하자

반응형: 화면이 처음엔 모바일 페이지였다가 점점 늘어나면서 컴포넌트가 재배치되면서 화면이 바뀐다,
  테블릿 페이지 -> 데스크탑 페이지
적응형: 모바일 페이지 따로 데스크탑 페이지 따로 테블릿 페이지따로

반응형을 할 수 있게 antd design 에서 지원을 해준다.

반응형으로 만든다면 모바일 디자인부터 만들어가자 (데스크탑부터하면 브레이크포인트 설정이 머리아프다?)
  효율성을 위해서는 모바일부터 다음 테블릿 다음 데스크탑으로 넓혀가야한다

가로부터해서 세로를 만들자
  <Row>
    <Col xs={24} md={6} />
    <Col xs={24} md={12} />
    <Col xs={24} md={6} />
  </Row>
    xs mobile, sm tablet, md small desktop, lg middle screen, xl full screen

{/*컬럼 사이의 간격 gutter*/}

타겟 블랭크를 사용할때엔 보안의 위험때문에 아래와같이 설정해두자
  target={'_blank'} rel="noreferrer noopener" // 새창을 누가열었는지 알 수 없게만듬

dummy data : 의미없는 data 이지만, 빈 공간을 채워야할 때 사용? db가 없을때 test 로 채워쓰기

보통 component file 들은 component folder 에 정리해놓고 pages 에서 꺼내사용한다

components = presenters :
  전에는 화면 보여주는것은 component 에 넣어두고 data 들어가는 것은 컨테이너에 넣었었다.

form 은 수작업말고 리액트 라이브러리를 활용하는게 좋다.
link 에는 href 넣고 a tag 에는 안넣는게 좋다.

label 사용시 input tag 에 id 가있으면 라벨 클릭시에 인풋이 포커스가된다.

Link 태그는 내부 next/router로 내부 페이지 라우팅 용

class였을때는 객체 state를 많이 썼지만 hooks일 때는 보통 속성별로 따로 선언,
  불변성 지키기가 귀찮, class의 setState는 최상위객체는
    알아서 shallow compare를 해주지만 hooks는 그런게 없음

보통 리액트 컴포넌트는 대문자로 시작. 
  또는 클래스, 인터페이스, 그 외에는 소문자로 하고, next에서는 page는 소문자

code inline style 로 <div style={{ marginTop: '10px'}}> 와 같이 사용하면안된다.
  객체 === 객체는 false
    
-----------------------------

### inline style 을 넣으면 렌더링 최적화가 되지않기에 아래와같이한다

import styled from 'styled-components';
// 디브 컴포넌트이면서 css 가 적용된 ButtonWrapper component 생성됨
const ButtonWrapper = styled.div` // div tag 가 된다.
  margin-top: 10px; 
`;
-----------------------------
import { Menu, Input, Row, Col } from 'antd'; // antd 에 Menu 사용
import styled from 'styled-components';

const SearchInput = styled(Input.Search)` // antd 에서 사용한 Input.Search 를 styled component 로 바꿔 넣어줌
  verticalAlign: middle;
`;
-----------------------------
const style = useMemo(()=>({ // styled component 를 사용원치 않을때 useMemo 사용
    marginTop: 10
  }), []);

<ButtonWrapper style={style}>
-----------------------------
useMemo : 값 캐싱, useCallback: 함수 캐싱
-----------------------------
버츄얼 돔
  return 부분이 버츄얼 돔이라고 생각하면된다.
    리액트에서 한번은 return 을 그려주고 리렌더링을 됐을때
    - 버츄얼 돔으로된게 이전 컴포넌트의 버츄얼돔과,
     --지금 컴포넌트의 버츄얼돔 중 바뀐게있으면,
     ---버츄얼 돔에서 달라진 부분을 리액트에 알려주기때문에 바뀐 부분만 다시그린다.
-----------------------------
css 관련, 공식문서 참고하자-----
전역 스타일시트 추가
  pages 폴더에 _app.js 에 import '../styles.css' 파일명 
    아마도 next 10 버전 이후로는 각 폴더마다 따로 줄수있다고도하는듯?

타사 구성요소에 필요한 css 가져오는방법
  pages 폴더에 _app.js 에 import 'bootstrap/dist/css/bootstrap.css'
    이후 원하는 컴포넌트 js 에서 <button className="close-button" onClick={close}>
      위 와 같이 사용하면됨

스타일시트 및 전역 css 파일 
  CSS 모듈은 선택적 기능 이며.module.css 확장자 가 . 일반 <link>스타일시트 및 전역 CSS 파일은 계속 지원됩니다.
    ex: components/Button.module.css먼저 다음 내용 으로 만듬
 .error {
  color: white;
  background-color: red;
}
그런 다음 components/Button.js위의 CSS 파일을 가져와서 사용합니다.
  import styles from './Button.module.css'
    export function Button() {
  return (
    <button
      type="button"
      // Note how the "error" class is accessed as a property on the imported
      // `styles` object.
      className={styles.error}
    >
      Destroy
    </button>
  )
}
---------------------
sass 지원함 사용원한다면 공식문서 다시보자 
====================================
<Form onFinish={onSubmitFrom}> {/*onFinish 는 이미 e.preventDefault() 가 적용되어있다.*/}
  그러므로 antd 에서는 onSubmitFrom 함수에 별도의 preventDefault 를 지정하면안된다.
-----------------------------
dummy data (가상의 useState) 를 활용해서 백엔드 없이 테스트 가능하다
-----------------------------
next 는 세미콜론을 사용하지 않는다,
  문장의 길이는 100 을 넘기지않도록한다
    싱글 쿼트를 사용한다

<div key="twit">짹짹<br />0</div>,  /*리액트에서 배열로 jsx 사용할땐 key 붙여줘야함*/

padding: 10px !important 같이 우선순위를 올릴수있다.

```