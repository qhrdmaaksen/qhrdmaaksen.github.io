---
layout: post
title: "알고리즘 실무 이론01"
---

## 대학 알고리즘 실무 정리

```js
알고리즘은 문제를 해결하는 방법의 절차!
프로그램의 핵심은 문제 해결!
--------------------------------------------------------------------------------------------------
프로그램 = 데이터 + 명령어

프로그램의 핵심요소
- 자료구조
- 알고리즘
- 프로그램 구조

좋은 프로그램 = 생산성 높은 프로그램(재사용 가능하며, 변화(확장성)할수있어야하며, 유지보수 편리하며 수정할수있어야한다)

알고리즘의 만족 조건
- 0개이상의 입력
- 1개이상의 출력
- 명확성 = 실행 명령어의 의미가 모호하지 않게 명확해야함
- 유효성 = 정확하게 실행 가능한 명령과 연산이어야함
- 유한성 = 반드시 종료해야함

알고리즘 계산 복잡도
- 시간 복잡도 = 특정한 크기의 입력에 대해 알고리즘의 수행 시간 분석
- 공간 복잡도 = 특정한 크기의 입력에 대해 알고리즘의 메모리 사용량 분석

연산 횟수로 측정하는 빅오 표기법
- 입력 크기 n 에 대해 계산 횟수가 어느정도인지를 표현
- 점근 표기법으로 알고리즘의 수행 시간을 대략적으로 나탕냄

빅오 표기법
-가장 빠르게 증가하는 항만을 고려하는 표기법
--함수의 상한만을 나타내게 됨
ex: 연산횟수가 3n3+5n2+10000000 인 알고리즘에선 제일 큰 항인 O(n3) 표기

O(1),O(n),O(n2(n의2승))

대표적인 알고리즘 시간 복잡도(어렵다;좀더 찾아보고 공부 더 해야할듯)
[n=32 일 경우]
O(1) = 해시 테이블(입력크기와 상관없이 일정한 시간) = 1 상수시간
O(log2n) = 이진 탐색(로그시간 수행시간 증가) = 5  로그시간
O(n) = 순차 탐색(입력 크기와 비례적인 수행시간 증가) = 32 선형시간
O(n log2n) = 퀵 정렬(O(n)보다는 수행시간이 길지만 O(n2)보다는 작음) = 160 로그선형시간
O(n2) = 선택정렬(두 for 가 중첩되어 구현) = 1024 이차시간
O(n3) = n 의 3제곱으로 수행시간 증가 = 32768 삼차 시간
O(2n) 지수 시간

------------------------------------------------------------------------
stack = 함수 동작시 생성 , 함수 종료시 소멸 ( LIFO ) ( FILO )
  - 정적 배열 ( 컴파일 시간 메모리 위치 결정 )
heap
  - 동적 배열 ( 실시간에 메모리 위치 결정 ) , ( 사용자가 직접 소멸 시킬 수 있다.)

비 객체 지향 언어
  - COBOL
  - PASCAL
  - C
  - Lua
객체 지향 언어
  - JAVA
  - C++
  - C
  - Python
================================================================
절차적 프로그램
  - 함수 중심적
객체지향 프로그램
  - 객체 중심적
값 데이터
  - 값을 직접 메모리에 저장함
참조 데이터
  - 값의 위치인 참조를 메모리에 저장함

연결리스트
  노드 기반의 자료구조 원소들이 순차적으로 연결되어있는 자료구조

단일 연결리스트
  내 다음 data 알수있다
이중 연결리스트
  내 바로 전과 내 다음 data 알 수 있다
    (만약 앞이나 뒤에 더이상 data 가 없다면 null)

노드
  데이터부와 연결부로 이뤄지며, 연결 리스트의 원소를 보관하고 다음 원소의 위치를 갖는 연결 리스트의 단위

추상화라는 작업을 통해 클래스가 만들어진다.
  객체는 클래스로부터 만들어진다.
    객체는 상태와 함수로 이뤄진다.
==============================================
stack frame :
  스택에 쌓은 함수의 정보를 가르킴

함수 호출의 트리구조 표현:
  왼쪽에있는 함수들이 실행이된다. 정방향 호출 역방향 리턴

재귀함수 필수조건:
  종료 조건을 가져야함
  재귀 함수 호출 시 종료 값에 수렴해 가야함

재귀함수:
  자기를 호출했던 곳으로만 되돌아갈수있다.
  자신의 함수를 재 호출하는 함수
  상태값들이 모두 다른 동일한 명령어의 함수를 호출
직접 재귀함수:
  a() 함수에서 a() 함수 호출형태
간접 재귀함수:
  a() 함수에서 b() 함수 호출하고 b()  함수에서 a() 함수 호출 형태
선형 재귀함수:
  하나의 방향으로 순차적으로 쭉 실행되었다가 쭉 종료되는것
비선형 재귀함수: 와리가리
==============================================
정렬 알고리즘
  내부 정렬
    :모든 데이터가 주기억 장치에 저장된 상태에서 정렬
  외부 정렬
    :대부분의 데이터가 외부기억장치등에 저장된 상태에서 정렬됨

선택정렬 ( 오름차순 )
  1단계 n 개의 원소 중에 가장 작은 값을 선택
  2단계 선택된 원소를 순차적으로 위치시킴
버블정렬 ( 오름차순 )
  1단계 이웃 원소와 크기를 비교함
  2단계 다음 원소가 작으면 서로 교환함
삽입정렬 ( 오름차순 )
  1단계 n 개의 원소중 2번째 원소부터 차례로 원소를 선택
  2단계 앞쪽 원소들의 정렬될 위치에 삽입함
퀵정렬
  1단계 전체 원소들에서 임의의 기준원소를 선택하고,
    기준 원소보다 작은 원소들은 왼쪽에 큰 원소들은 오른쪽에 위치시킴
  2단계 이렇게 나눠둔 왼쪽과 오른쪽 원소들을 
    각각 다시 1단계와 같은 방법으로 분할함
  3단계 1단계와 2단계가 더이상 원소들을 
    나눌수 없을때까지 반복하여 정렬된 원소들을 얻음
================================================================
해시 (테이블 or bucket)
입력할 원소(key) 를 저장할 테이블을 만들고 원소를 연산(hash function) 하여
얻은 테이블 주소로 직접 저장된 원소를 접근 할 수 있는 자료구조

해싱
해시테이블을 이용한 탐색(이론적 탐색 시간은 O(1))

입력원소에대해 해시 연산을 거치게되면 원소에대한 주소를 반환하며 해당 주소에
값이 저장된다, 그렇기에 해당 원소의 주소를 알면 값을 찾을 수 있다

해시테이블은 저장공간 table or bucket 메모리 공간을 만든다

해시테이블의 충돌
  해시 함수가 서로 다른 입력 원소에 대해 같은 해시테이블의 주소를 반환
  실제 해시함수의 충돌은 피할 수 없음
충돌 해결방법
  개방 해싱
    해시테이블 바깥에 새로운 공간을 만들어서 문제를 해결
  폐쇄 해싱
    해시테이블 공간 안에서 문제를 해결

체이닝
  충돌이 발생했을때 같은 주소에있는 원소를 링크드 리스트나 이진 탐색트리 등
    외부에 공간을 만들어 원소들을 연결하여 삽입하는 기법

해시 펑션 핵심
  테이블을 늘리거나, 원소가 참조할 주소가 충돌하지않도록 최대한 랜덤하게
  하는것

(해시개념)
메모리를 버리고 시간을 얻는다 
================================================================
그래프
  연결의 집합을 모형화한 것
  객체와 객체 간의 연결을 표현하기 위한 자료구조
자료구조 그래프
  정점과 간선들의 집합
    정점 : 객체
    간선 : 객체 간의 연결
    그래프 G : (V,E)로 표기
그래프의 표현
  인접 행렬 : 정점 간의 인접 관계를 행렬로 표현
  인접 리스트 : 정점 간의 인접 관계를 연결 리스트로 표현
그래프의 순회
  깊이 우선 탐색
    출발 정점부터 시작해서 깊이를 우선으로 인접한 정점들을 최대한 깊이 
      탐색하는 방법
  너비 우선 탐색
    출발 정점부터 가까운 인접한 정점들을 우선으로 탐색하는 방법
  ================================================================
다익스트라 알고리즘
  다익스트라가 고안한 알고리즘
  최단 경로 알고리즘의 가장 대표적인 알고리즘
  최단 경로는 최단 경로들로 이루어져 있다는 개념에서 출발
  사이클이 없는 방향성 그래프에서 사용됨

시작 정점에서 모든 정점으로 가는 최단 경로를 구함
  초기값 설정: 출발 정점의 경로의 길이는 0으로 설정하고 나머지 모든 정점은
    무한대로 설정함
  1단계: 0정점을 시작 정점으로 한다면 0정점은 0이고 나머지는 모두 무한대임
  2단계: 정점 기준 길이
================================================================
동적 계획법 알고리즘
  가장 작은 부분의 문제부터 해결하여 전체 문제를 해결해가며 최적의 답을     
    찾는 알고리즘
동적 계획법의 알고리즘 단계
  문제를 부분 문제로 나누기
  가장 작은 부분 문제의 해를 구하여 테이블에 저장하기
  테이블에 저장된 부분 문제의 해를 이용해 상위 부분 문제의 최적해 구하기
동적 계획법의 특징
  최적의 답을 해결하는 다양한 문제에 사용가능, 일률적인 공식은 존재하지않음
  큰 문제를 작은 문제로나누어 작은 문제를 해결함으로써 큰 문제를 해결함
  테이블을 이용해 문제를 해결
  테이블의 인덱스는 하위 문제를 의미하며 내용은 최적화 값을 의미함

피보나치 수 동적 계획법
최장 공통
================================================================
탐욕 알고리즘
  알고리즘이 단순하고 해법이 빠름
  최종의 해가 최적해가 아닐 수 있다. 최적해 성공을 보장하지 않음
탐욕 알고리즘으로 풀기 위한 문제 조건
  최적 부분 구조
    부분 문제의 최적해가 전체 문제의 최적해인 구조
  탐욕 선택 조건
    앞의 선택이 다음 선택에 영향을 주지 않음 독립적임













```
