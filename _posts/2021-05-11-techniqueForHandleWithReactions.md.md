---
layout: post
title: "리액트를 다루는 기술 정리"
---

## 코드는 재산이다, 나중에 도움된다, 정리잘하자

```js
--------------------------------------------------------
리액트는 구조가 mvc, mvw 등의 프레임워크와 달리 오직 view 만 싱경쓰는 라이브러리임
--------------------------------------------------------
컴포넌트: 재사용이 가능한 api 로 수많은 기능을 내장하고 있으며 컴포넌트 하나에 해당 컴포넌트의 생김새와 작동을 정의함
--------------------------------------------------------
render : 이 함수는 컴포넌트가 어떻게 생겼는지 정의하는 역할을 함/html 형식의 문자열을 반환하지않으며 뷰가 어떻게 생겼고 어떻게 작동하는지에대한 정보를 지닌 객체를 반환함/컴포넌트 내부에 또다른 컴포넌트들이 들어갈 수 있으며 이때 render 함수를 실행 시 내부에있는 컴포넌트들도 재귀적으로 렌더링함/최상위 컴포넌트의 렌더링이 끝나면 지니고있는 정보들을 사용해 html 마크업을 만들고 이를 우리가 정하는 실제 페이지의 돔 요소 안에 주입함/ 컴포넌트를 실제 페이지에 렌더링할땐 분리된 두가지 절차가 따르며 문자열 형태의 html 코드를 생성한 후 특정 dom 에 해당 내용을 주입하면 이벤트가 적용됨
--------------------------------------------------------
Virtual DOM
-실제 돔에 접근해 조작하는대신 추상화한 js 객체를 구성해 사용한다 예를들면 실제 돔의 가벼운 사본과 비슷함
-리액트에서 데이터가 변하면 웹 브라우저에 실제 돔을 업데이트할땐 3가지 절차를 밟음
--1.데이터를 업데이트하면 전체 ui 를 버츄얼 돔에 리렌더링함
--2.이전 버츄얼 돔에있던 내용과 현재 내용을 비교함
--3.바뀐 부분만 실제 돔에 적용함
--------------------------------------------------------
DOM
-document object model 객체로 문서 구조를 표현하는 방법으로 xml 이나 html 로 작성함
-웹 브라우저는 dom 을 활용해 객체에 자바스크립트와 css 를 적용함/ 돔은 트리 형태라 특정 노드를 찾거나 수정하거나 제거하거나 원하는 곳에 삽입할수있음
-돔의 치명적인 한가지 문제점은 동적 ui 에 최적화되어있지 않다/ html 은 자체적으로는 정적이며 js 를 사용해 이를 동적으로 만든다
-돔 자체는 빠르며 돔 자체를 읽고 쓸때의 성능은 js 객체 처리할때 성능과 비교하면 다르지않다
-웹 브라우저 단에서 돔에 변화가 일어나면 웹 브라우저가 css 를 다시 연산하고 레이아웃을 구성하고 페이지를 리 페인트하는데 이 과정에서 시간이 허비되는것임
--------------------------------------------------------
설치

node.js
-react app 은 웹 브라우저에서 실행되는 코드이므로 직접적인 연관은없지만 프로젝트를 개발하는데 필요한 주요도구들(ecmascript 를 호환시켜주는 바벨/ 모듈화된 코드를 한파일로 합치고(번들링) 코드를 수정할때마다 웹 브라우저를 리로딩하는 등의 여러기능을 가진 웹펩 등)

yarn
- npm 을 대체할 수 있는 도구이며  npm 보다 더 빠르고 효율적인 캐시 시스템 및 기타 부가 기능을 제공
--------------------------------------------------------
대표적인 번들러로 웹팩, 파셀 브라우저ify 도구들이있으며 리액트에서는 주로 웹팩을 사용

번들러 도구를 사용하면 import or require 로 모듈을 불러왔을때 불러온 모듈을 모두 합쳐서 하나의 파일을 생성해줌/ 최적화 과정에서 여러개의 파일로 분리될 수수도있음
--------------------------------------------------------
jsx
-js 확장 문법이며 xml 과 비슷하게 생김/브라우저에서 실행되기 전에 코드가 번들링되는 과정에서 바벨을 사용해 일반 js 형태의 코드로 변환됨
-컴포넌트에 여러 요소가 있다면 반드시 부모 요소 하나로 감싸야 함
--버츄얼 돔에서 컴포넌트 변화를 감지해 낼 때 효율적으로 비교할수있도록 컴포넌트 내부는 하나의 돔트리 구조로 이루어져야한다는 규칙때문임

jsx 는 공식적인 js 문법이 아님

jsx 장점
-가독성이 높고 작성하기 쉽다
-js 요소들을 일일이 만들어야하면 불편하기때문에 사용
-jsx 는 html tag 를 사용할수 있으며 컴포넌트도 jsx 안에서 작성가능


리액트 컴포넌트에서는 함수에서 undefined 만 반환하여 렌더링하는 상황을 만들면안된다. 만약 어떤 값이 undefined 일 수 있다면 or 연산자를 사용해 해당 값이 undefined 일 때 사용할 값을 지정할 수 있고 이로인해 오류를 방지 할 수 있다
-jsx 내부에서 undefined 를 렌더링하는것은 괜찮음
--------------------------------------------------------
ReactDOM.render
-컴포넌트를 페이지에 렌더링하는 역할을 함
-react-dom module 을 불러와 사용할 수 있음
-이 함수의 첫번째 파라미터에는 페이지에 렌더링할 내용을 jsx 형태로 작성/ 두번째 파라미터에는 해당 jsx 를 렌더링할 document 내부 요소를 설정함
--------------------------------------------------------
화살표 함수
-화살표 함수는 주로 함수를 파라미터로 전달할 때 유용함
-기존 function 을 대체 할수없는것은 용도가 다르기때문임 서로 가르키고있는 this 값이 다름
--일반 함수는 자신이 종속된 객체를 this 로 가리키며 화살표 함수는 자신이 종속된 인스턴스를 가리킴
-화살표 함수는 값을 연산하여 바로 반환해야할때 사용하면 가독성을 높일 수 있음
--------------------------------------------------------
props
-컴포넌트 속성을 설정할때 사용하는 요소 / 프롭스 값은 해당 컴포넌트를 불러와 사용하는 부모 컴포넌트에서 설정할 수있음

default props setting
ex code
MyComponent.defaultProps ={
  name: 'vitamin'
}


비구조화 할당 문법 통해 props 내부 값 추출
ex code
const {name, children} = props;

/** 프롭 타입 세팅 및 타입 오류 시 경고 메시지 출력토록 isRequired 설정*/
MyPropsTypeComponent.propTypes = {
	name: PropTypes.string,
  myNumber: PropsTypes.number.isRequired,
}

-props 는 컴포넌트가 사용되는 과정에서 부모 컴포넌트가 설정하는 값이며 컴포넌트 자신은 해당 props 를 읽기 전용으로만 사용할수있고/ props 를 바꾸려면 부모컴포넌트에서 바꿔줘야한다

PropTypes 종류
-array: 배열
-arrayOf: 특정 PropType 으로 이루어진 배열을 의미, ex arrayOf(PropTypes.number)는 숫자로 이루어진 배열
-bool: true or false value 
-fuc: 함수
-number: 숫자
-object: 객체
-string: 문자열
-symbol: es6 의 Symbol
-node: 렌더링할 수 있는 모든 것
-instanceOf:특정 클래스의 인스턴스
-oneOf(['dog','cat']): 주어진 배열 요소 중 값 하나
-oneOfType([React.PropTypes.string, PropTypes.number]): 주어진 배열안에 종류중 하나
-objectOf(React.PropTypes.number):객체의 모든 키 값이 인자로 주어진 PropType 인 객체 
-shape({name:PropTypes.string, num:PropTypes.number}): 주어진 스키마를 가진 객체
-any: 아무 종류


defaultProps & PropTypes 는 사용해도되고 안해도되지만 큰 규모에 협업 프로젝트에서는 개발자들끼리 헷갈리지않도록 사용해주는게 좋다.
--------------------------------------------------------
state
-컴포넌트 내부에서 바뀔수 있는 값을 의미

--------------------------------------------------------
class component

-클래스형 컴포넌트에서 constructor 를 작성시 반드시 super(props) 를 호출해줘야함 이 함수가 호출되면 현재 클래스 컴포넌트가 상속받고있는 리액트의 component 클래스가 지닌 생성자 함수를 호출해줌
--------------------------------------------------------
배열 비구조화 할당
ex code
const array = [1, 2]
const one = array[0]
const tow = array[1]
을
const [one, tow] = array
--------------------------------------------------------
--------------------------------------------------------



```